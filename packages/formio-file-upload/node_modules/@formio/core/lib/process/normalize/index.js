"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeProcessInfo = exports.normalizeProcessSync = exports.normalizeProcess = void 0;
const lodash_1 = require("lodash");
const dayjs_1 = __importDefault(require("dayjs"));
const customParseFormat_1 = __importDefault(require("dayjs/plugin/customParseFormat"));
dayjs_1.default.extend(customParseFormat_1.default);
const isAddressComponent = (component) => component.type === 'address';
const isDayComponent = (component) => component.type === 'day';
const isEmailComponent = (component) => component.type === 'email';
const isRadioComponent = (component) => component.type === 'radio';
const isSelectComponent = (component) => component.type === 'select';
const isSelectBoxesComponent = (component) => component.type === 'selectboxes';
const isTagsComponent = (component) => component.type === 'tags';
const isTextFieldComponent = (component) => component.type === 'textfield';
const isTimeComponent = (component) => component.type === 'time';
const isNumberComponent = (component) => component.type === 'number';
const normalizeAddressComponentValue = (component, value) => {
    if (!component.multiple && Boolean(component.enableManualMode) && value && !value.mode) {
        return {
            mode: 'autocomplete',
            address: value,
        };
    }
    return value;
};
const getLocaleDateFormatInfo = (locale = 'en') => {
    const formatInfo = {};
    const day = 21;
    const exampleDate = new Date(2017, 11, day);
    const localDateString = exampleDate.toLocaleDateString(locale);
    formatInfo.dayFirst = localDateString.slice(0, 2) === day.toString();
    return formatInfo;
};
const getLocaleDayFirst = (component, form) => {
    var _a;
    if (component.useLocaleSettings) {
        return getLocaleDateFormatInfo((_a = form.options) === null || _a === void 0 ? void 0 : _a.language).dayFirst;
    }
    return component.dayFirst;
};
const normalizeDayComponentValue = (component, form, value) => {
    // TODO: this is a quick and dirty port of the Day component's normalizeValue method, may need some updates
    const valueMask = /^\d{2}\/\d{2}\/\d{4}$/;
    const isDayFirst = getLocaleDayFirst(component, form);
    const showDay = !(0, lodash_1.get)(component, 'fields.day.hide', false);
    const showMonth = !(0, lodash_1.get)(component, 'fields.month.hide', false);
    const showYear = !(0, lodash_1.get)(component, 'fields.year.hide', false);
    if (!value || valueMask.test(value)) {
        return value;
    }
    const dateParts = [];
    const valueParts = value.split('/');
    const [DAY, MONTH, YEAR] = component.dayFirst ? [0, 1, 2] : [1, 0, 2];
    const defaultValue = component.defaultValue ? component.defaultValue.split('/') : '';
    let defaultDay = '';
    let defaultMonth = '';
    let defaultYear = '';
    const getDayWithHiddenFields = (parts) => {
        let DAY, MONTH, YEAR;
        [DAY, MONTH, YEAR] = component.dayFirst ? [0, 1, 2] : [1, 0, 2];
        if (!showDay) {
            MONTH = MONTH === 0 ? 0 : MONTH - 1;
            YEAR = YEAR - 1;
            DAY = null;
        }
        if (!showMonth) {
            if (!(0, lodash_1.isNull)(DAY)) {
                DAY = DAY === 0 ? 0 : DAY - 1;
            }
            YEAR = YEAR - 1;
            MONTH = null;
        }
        if (!showYear) {
            YEAR = null;
        }
        return {
            month: (0, lodash_1.isNull)(MONTH) ? '' : parts[MONTH],
            day: (0, lodash_1.isNull)(DAY) ? '' : parts[DAY],
            year: (0, lodash_1.isNull)(YEAR) ? '' : parts[YEAR],
        };
    };
    const getNextPart = (shouldTake, defaultValue) => {
        // Only push the part if it's not an empty string
        const part = shouldTake ? valueParts.shift() : defaultValue;
        if (part !== '') {
            dateParts.push(part);
        }
    };
    if (defaultValue) {
        const hasHiddenFields = defaultValue.length !== 3;
        defaultDay = hasHiddenFields ? getDayWithHiddenFields(defaultValue).day : defaultValue[DAY];
        defaultMonth = hasHiddenFields
            ? getDayWithHiddenFields(defaultValue).month
            : defaultValue[MONTH];
        defaultYear = hasHiddenFields ? getDayWithHiddenFields(defaultValue).year : defaultValue[YEAR];
    }
    if (isDayFirst) {
        getNextPart(showDay, defaultDay);
    }
    getNextPart(showMonth, defaultMonth);
    if (!isDayFirst) {
        getNextPart(showDay, defaultDay);
    }
    getNextPart(showYear, defaultYear);
    return dateParts.join('/');
};
const normalizeRadioComponentValue = (value, dataType) => {
    switch (dataType) {
        case 'number':
            return +value;
        case 'string':
            return typeof value === 'object' ? JSON.stringify(value) : String(value);
        case 'boolean':
            return !(!value || value.toString() === 'false');
    }
    const isEquivalent = (0, lodash_1.toString)(value) === Number(value).toString();
    if (!isNaN(parseFloat(value)) && isFinite(value) && isEquivalent) {
        return +value;
    }
    if (value === 'true') {
        return true;
    }
    if (value === 'false') {
        return false;
    }
    return value;
};
const normalizeSingleSelectComponentValue = (component, value) => {
    if ((0, lodash_1.isNil)(value)) {
        return;
    }
    const valueIsObject = (0, lodash_1.isObject)(value);
    //check if value equals to default emptyValue
    if (valueIsObject && Object.keys(value).length === 0) {
        return value;
    }
    const dataType = component.dataType || 'auto';
    const normalize = {
        value,
        number() {
            const numberValue = Number(this.value);
            const isEquivalent = value.toString() === numberValue.toString();
            if (!Number.isNaN(numberValue) &&
                Number.isFinite(numberValue) &&
                value !== '' &&
                isEquivalent) {
                this.value = numberValue;
            }
            return this;
        },
        boolean() {
            if ((0, lodash_1.isString)(this.value) &&
                (this.value.toLowerCase() === 'true' || this.value.toLowerCase() === 'false')) {
                this.value = this.value.toLowerCase() === 'true';
            }
            return this;
        },
        string() {
            this.value = String(this.value);
            return this;
        },
        object() {
            return this;
        },
        auto() {
            if ((0, lodash_1.isObject)(this.value)) {
                this.value = this.object().value;
            }
            else {
                this.value = this.string().number().boolean().value;
            }
            return this;
        },
    };
    try {
        return normalize[dataType]().value;
    }
    catch (err) {
        console.warn('Failed to normalize value', err);
        return value;
    }
};
const normalizeSelectComponentValue = (component, value) => {
    if (component.multiple && Array.isArray(value)) {
        return value.map((singleValue) => normalizeSingleSelectComponentValue(component, singleValue));
    }
    return normalizeSingleSelectComponentValue(component, value);
};
const normalizeSelectBoxesComponentValue = (value) => {
    if (!value) {
        value = {};
    }
    if (typeof value !== 'object') {
        if (typeof value === 'string') {
            return {
                [value]: true,
            };
        }
        else {
            return {};
        }
    }
    if (Array.isArray(value)) {
        return value.reduce((acc, curr) => {
            return Object.assign(Object.assign({}, acc), { [curr]: true });
        }, {});
    }
    return value;
};
const normalizeTagsComponentValue = (component, value) => {
    const delimiter = component.delimeter || ',';
    if ((!component.hasOwnProperty('storeas') || component.storeas === 'string') &&
        Array.isArray(value)) {
        return value.join(delimiter);
    }
    else if (component.storeas === 'array' && typeof value === 'string') {
        return value.split(delimiter).filter((result) => result);
    }
    return value;
};
const normalizeMaskValue = (component, defaultValues, value, path) => {
    if (component.inputMasks && component.inputMasks.length > 0) {
        if (!value || typeof value !== 'object') {
            return {
                value: value,
                maskName: component.inputMasks[0].label,
            };
        }
        if (!value.value) {
            const defaultValue = defaultValues === null || defaultValues === void 0 ? void 0 : defaultValues.find((defaultValue) => defaultValue.path === path);
            value.value =
                Array.isArray(defaultValue) && defaultValue.length > 0 ? defaultValue[0] : defaultValue;
        }
    }
    return value;
};
const normalizeTextFieldComponentValue = (component, defaultValues, value, path) => {
    // If the component has truncate multiple spaces enabled, then normalize the value to remove extra spaces.
    if (component.truncateMultipleSpaces && typeof value === 'string') {
        value = value.trim().replace(/\s{2,}/g, ' ');
    }
    if (component.allowMultipleMasks && component.inputMasks && component.inputMasks.length > 0) {
        if (Array.isArray(value)) {
            return value.map((val) => normalizeMaskValue(component, defaultValues, val, path));
        }
        else {
            return normalizeMaskValue(component, defaultValues, value, path);
        }
    }
    return value;
};
// Allow submissions of time components in their visual "format" property by coercing them to the "dataFormat" property
// i.e. "HH:mm" -> "HH:mm:ss"
const normalizeTimeComponentValue = (component, value) => {
    const defaultDataFormat = 'HH:mm:ss';
    const defaultFormat = 'HH:mm';
    if ((0, dayjs_1.default)(value, component.format || defaultFormat, true).isValid()) {
        return (0, dayjs_1.default)(value, component.format || defaultFormat, true).format(component.dataFormat || defaultDataFormat);
    }
    return value;
};
const normalizeSingleNumberComponentValue = (component, value) => {
    if (!isNaN(parseFloat(value)) && isFinite(value)) {
        return +value;
    }
    return value;
};
const normalizeNumberComponentValue = (component, value) => {
    if (component.multiple && Array.isArray(value)) {
        return value.map((singleValue) => normalizeSingleNumberComponentValue(component, singleValue));
    }
    return normalizeSingleNumberComponentValue(component, value);
};
const normalizeProcess = (context) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, exports.normalizeProcessSync)(context);
});
exports.normalizeProcess = normalizeProcess;
const normalizeProcessSync = (context) => {
    var _a, _b;
    const { component, form, scope, path, data, value } = context;
    if (!scope.normalize) {
        scope.normalize = {};
    }
    const { defaultValues } = scope;
    scope.normalize[path] = {
        type: component.type,
        normalized: false,
    };
    let newValue = value;
    if (isAddressComponent(component)) {
        newValue = normalizeAddressComponentValue(component, value);
    }
    else if (isDayComponent(component)) {
        newValue = normalizeDayComponentValue(component, form, value);
    }
    else if (isEmailComponent(component)) {
        newValue = value && (0, lodash_1.isString)(value) ? value.trim().toLowerCase() : value;
    }
    else if (isRadioComponent(component)) {
        newValue = normalizeRadioComponentValue(value, component.dataType);
    }
    else if (isSelectComponent(component)) {
        newValue = normalizeSelectComponentValue(component, value);
    }
    else if (isSelectBoxesComponent(component)) {
        newValue = normalizeSelectBoxesComponentValue(value);
    }
    else if (isTagsComponent(component)) {
        newValue = normalizeTagsComponentValue(component, value);
    }
    else if (isTextFieldComponent(component)) {
        newValue = normalizeTextFieldComponentValue(component, defaultValues, value, path);
    }
    else if (isTimeComponent(component)) {
        newValue = normalizeTimeComponentValue(component, value);
    }
    else if (isNumberComponent(component)) {
        newValue = normalizeNumberComponentValue(component, value);
    }
    if (component.multiple && !((_a = component.validate) === null || _a === void 0 ? void 0 : _a.required) && !Array.isArray(value)) {
        newValue = value ? [value] : [];
    }
    if (newValue === undefined || newValue === null) {
        scope.filter = scope.filter || {};
        scope.filter[path] = false;
    }
    else if (value !== newValue && !((_b = scope.clearHidden) === null || _b === void 0 ? void 0 : _b.hasOwnProperty(path))) {
        (0, lodash_1.set)(data, path, newValue);
        scope.normalize[path].normalized = true;
        scope.filter = scope.filter || {};
        scope.filter[path] = true;
    }
};
exports.normalizeProcessSync = normalizeProcessSync;
exports.normalizeProcessInfo = {
    name: 'normalize',
    shouldProcess: () => true,
    process: exports.normalizeProcess,
    processSync: exports.normalizeProcessSync,
};
