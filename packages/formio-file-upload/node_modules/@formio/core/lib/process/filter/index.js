"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterProcessInfo = exports.filterPostProcess = exports.filterPostProcessSync = exports.filterProcess = exports.filterProcessSync = void 0;
const lodash_1 = require("lodash");
const lodash_2 = require("lodash");
const formUtil_1 = require("../../utils/formUtil");
const filterProcessSync = (context) => {
    const { scope, path, value } = context;
    if (!scope.filter)
        scope.filter = {};
    if (value !== undefined) {
        scope.filter[path] = true;
    }
};
exports.filterProcessSync = filterProcessSync;
const filterProcess = (context) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, exports.filterProcessSync)(context);
});
exports.filterProcess = filterProcess;
const filterPostProcessSync = (context) => {
    const { scope, path, data, component, value } = context;
    if (!scope.filter)
        scope.filter = {};
    if (value === undefined || !scope.filter[path]) {
        return;
    }
    scope.filtered = scope.filtered || {};
    const modelType = (0, formUtil_1.getModelType)(component);
    if (component.type === 'address' ||
        (modelType !== 'dataObject' &&
            modelType !== 'nestedArray' &&
            modelType !== 'nestedDataArray' &&
            modelType !== 'object')) {
        (0, lodash_1.set)(scope.filtered, path, value);
    }
    else {
        if (modelType === 'dataObject') {
            (0, lodash_1.set)(data, `${path}.data`, (0, lodash_2.get)(scope.filtered, `${path}.data`, (value === null || value === void 0 ? void 0 : value.data) || {}));
            (0, lodash_1.set)(scope.filtered, path, (0, lodash_2.get)(data, path));
        }
        else if (modelType === 'nestedDataArray') {
            const filtered = (0, lodash_2.get)(scope.filtered, path, []);
            (0, lodash_1.set)(scope.filtered, path, value.map((item, index) => {
                var _a;
                return Object.assign(Object.assign({}, item), { data: ((_a = filtered[index]) === null || _a === void 0 ? void 0 : _a.data) || {} });
            }));
        }
        else if (!(0, lodash_1.has)(scope.filtered, path)) {
            (0, lodash_1.set)(scope.filtered, path, value);
        }
        else {
            (0, lodash_1.set)(data, path, (0, lodash_2.get)(scope.filtered, path, value));
        }
    }
};
exports.filterPostProcessSync = filterPostProcessSync;
const filterPostProcess = (context) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, exports.filterPostProcessSync)(context);
});
exports.filterPostProcess = filterPostProcess;
exports.filterProcessInfo = {
    name: 'filter',
    process: exports.filterProcess,
    processSync: exports.filterProcessSync,
    postProcess: exports.filterPostProcess,
    postProcessSync: exports.filterPostProcessSync,
    shouldProcess: () => true,
};
