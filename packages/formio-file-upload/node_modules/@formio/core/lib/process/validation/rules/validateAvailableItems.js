"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAvailableItemsInfo = exports.validateAvailableItemsSync = exports.shouldValidate = exports.validateAvailableItems = void 0;
const lodash_1 = require("lodash");
const error_1 = require("../../../error");
const utils_1 = require("../../../utils");
const util_1 = require("../util");
const error_2 = require("../../../utils/error");
function isValidatableRadioComponent(component) {
    var _a;
    return component && component.type === 'radio' && !!((_a = component.validate) === null || _a === void 0 ? void 0 : _a.onlyAvailableItems);
}
function isValidateableSelectComponent(component) {
    var _a;
    return (component &&
        !!((_a = component.validate) === null || _a === void 0 ? void 0 : _a.onlyAvailableItems) &&
        component.type === 'select' &&
        component.dataSrc !== 'resource');
}
function isValidateableSelectBoxesComponent(component) {
    var _a;
    return component && !!((_a = component.validate) === null || _a === void 0 ? void 0 : _a.onlyAvailableItems) && component.type === 'selectboxes';
}
function mapDynamicValues(component, values) {
    return values.map((value) => {
        if (component.valueProperty) {
            return value[component.valueProperty];
        }
        return value;
    });
}
function mapStaticValues(values) {
    return values.map((obj) => obj.value);
}
const getAvailableDynamicValues = (component, context) => __awaiter(void 0, void 0, void 0, function* () {
    let _fetch = null;
    try {
        _fetch = context.fetch ? context.fetch : fetch;
    }
    catch (ignoreErr) {
        _fetch = null;
    }
    try {
        if (!_fetch) {
            console.log('You must provide a fetch interface to the fetch processor.');
            return null;
        }
        const response = yield _fetch(component.data.url, { method: 'GET' });
        const data = yield response.json();
        return data ? mapDynamicValues(component, data) : null;
    }
    catch (err) {
        console.error((0, error_2.getErrorMessage)(err));
        return null;
    }
});
function getAvailableSelectValues(component, context) {
    return __awaiter(this, void 0, void 0, function* () {
        if ((0, lodash_1.isUndefined)(component.dataSrc) && component.data.hasOwnProperty('values')) {
            component.dataSrc = 'values';
        }
        switch (component.dataSrc) {
            case 'values':
                if (Array.isArray(component.data.values)) {
                    return mapStaticValues(component.data.values);
                }
                throw new error_1.ProcessorError(`Failed to validate available values in static values select component '${component.key}': the values are not an array`, context, 'validate:validateAvailableItems');
            case 'json': {
                if (typeof component.data.json === 'string') {
                    try {
                        return mapDynamicValues(component, JSON.parse(component.data.json));
                    }
                    catch (err) {
                        throw new error_1.ProcessorError(`Failed to validate available values in JSON select component '${component.key}': ${err}`, context, 'validate:validateAvailableItems');
                    }
                }
                else if (Array.isArray(component.data.json)) {
                    // TODO: need to retype this
                    return mapDynamicValues(component, component.data.json);
                }
                else {
                    throw new error_1.ProcessorError(`Failed to validate available values in JSON select component '${component.key}': the values are not an array`, context, 'validate:validateAvailableItems');
                }
            }
            case 'custom': {
                const customItems = (0, utils_1.evaluate)(component.data.custom, {
                    values: [],
                }, 'values');
                if ((0, util_1.isPromise)(customItems)) {
                    const resolvedCustomItems = yield customItems;
                    if (Array.isArray(resolvedCustomItems)) {
                        return resolvedCustomItems;
                    }
                    throw new error_1.ProcessorError(`Failed to validate available values in JSON select component '${component.key}': the values are not an array`, context, 'validate:validateAvailableItems');
                }
                if (Array.isArray(customItems)) {
                    return customItems;
                }
                else {
                    throw new error_1.ProcessorError(`Failed to validate available values in JSON select component '${component.key}': the values are not an array`, context, 'validate:validateAvailableItems');
                }
            }
            case 'url':
                return yield getAvailableDynamicValues(component, context);
            default:
                throw new error_1.ProcessorError(`Failed to validate available values in select component '${component.key}': data source ${component.dataSrc} is not valid}`, context, 'validate:validateAvailableItems');
        }
    });
}
function getAvailableSelectValuesSync(component, context) {
    var _a;
    if ((0, lodash_1.isUndefined)(component.dataSrc) && component.data.hasOwnProperty('values')) {
        component.dataSrc = 'values';
    }
    switch (component.dataSrc) {
        case 'values':
            if (Array.isArray((_a = component.data) === null || _a === void 0 ? void 0 : _a.values)) {
                return mapStaticValues(component.data.values);
            }
            throw new error_1.ProcessorError(`Failed to validate available values in static values select component '${component.key}': the values are not an array`, context, 'validate:validateAvailableItems');
        case 'json': {
            if (typeof component.data.json === 'string') {
                try {
                    return mapDynamicValues(component, JSON.parse(component.data.json));
                }
                catch (err) {
                    throw new error_1.ProcessorError(`Failed to validate available values in JSON select component '${component.key}': ${err}`, context, 'validate:validateAvailableItems');
                }
            }
            else if (Array.isArray(component.data.json)) {
                // TODO: need to retype this
                return mapDynamicValues(component, component.data.json);
            }
            else {
                throw new error_1.ProcessorError(`Failed to validate available values in JSON select component '${component.key}': the values are not an array`, context, 'validate:validateAvailableItems');
            }
        }
        case 'custom': {
            const customItems = (0, utils_1.evaluate)(component.data.custom, {
                values: [],
            }, 'values');
            if (Array.isArray(customItems)) {
                return customItems;
            }
            else {
                throw new error_1.ProcessorError(`Failed to validate available values in JSON select component '${component.key}': the values are not an array`, context, 'validate:validateAvailableItems');
            }
        }
        case 'url':
            return null;
        default:
            throw new error_1.ProcessorError(`Failed to validate available values in select component '${component.key}': data source ${component.dataSrc} is not valid}`, context, 'validate:validateAvailableItems');
    }
}
function compareComplexValues(valueA, valueB, context) {
    if (!(0, util_1.isObject)(valueA) || !(0, util_1.isObject)(valueB)) {
        return false;
    }
    try {
        // TODO: we need to have normalized values here at this moment, otherwise
        // this won't work
        return JSON.stringify(valueA) === JSON.stringify(valueB);
    }
    catch (err) {
        throw new error_1.ProcessorError(`Error while comparing available values: ${err}`, context, 'validate:validateAvailableItems');
    }
}
const validateAvailableItems = (context) => __awaiter(void 0, void 0, void 0, function* () {
    const { component, value } = context;
    const error = new error_1.FieldError('invalidOption', context, 'onlyAvailableItems');
    try {
        if (isValidatableRadioComponent(component)) {
            if (value == null || (0, lodash_1.isEmpty)(value)) {
                return null;
            }
            const values = component.dataSrc === 'url'
                ? yield getAvailableDynamicValues(component, context)
                : component.values;
            if (values) {
                if ((0, util_1.isObject)(value)) {
                    return values.find((optionValue) => compareComplexValues(optionValue, value, context)) !==
                        undefined
                        ? null
                        : error;
                }
                return values.find((optionValue) => optionValue.value === value || optionValue === value) !== undefined
                    ? null
                    : error;
            }
            return null;
        }
        else if (isValidateableSelectComponent(component)) {
            if (value == null || (0, lodash_1.isEmpty)(value)) {
                return null;
            }
            const values = yield getAvailableSelectValues(component, context);
            if (values) {
                if ((0, util_1.isObject)(value)) {
                    return values.find((optionValue) => compareComplexValues(optionValue, value, context)) !==
                        undefined
                        ? null
                        : error;
                }
                return values.find((optionValue) => optionValue === value) !== undefined ? null : error;
            }
        }
        else if (isValidateableSelectBoxesComponent(component)) {
            if (value == null || (0, lodash_1.isEmpty)(value) || !(0, util_1.isObject)(value)) {
                return null;
            }
            const values = component.dataSrc === 'url'
                ? yield getAvailableDynamicValues(component, context)
                : component.values.map((val) => val.value);
            if (values) {
                return (0, lodash_1.difference)(Object.keys(value), values).length ? error : null;
            }
        }
    }
    catch (err) {
        throw new error_1.ProcessorError(err.message || err, context, 'validate:validateAvailableItems');
    }
    return null;
});
exports.validateAvailableItems = validateAvailableItems;
const shouldValidate = (context) => {
    const { component, value } = context;
    if (value == null || (0, lodash_1.isEmpty)(value)) {
        return false;
    }
    if (isValidatableRadioComponent(component)) {
        return true;
    }
    if (isValidateableSelectComponent(component)) {
        return true;
    }
    if (isValidateableSelectBoxesComponent(component)) {
        return true;
    }
    return false;
};
exports.shouldValidate = shouldValidate;
const validateAvailableItemsSync = (context) => {
    const { component, value } = context;
    const error = new error_1.FieldError('invalidOption', context, 'onlyAvailableItems');
    try {
        if (!(0, exports.shouldValidate)(context)) {
            return null;
        }
        if (isValidatableRadioComponent(component) && component.dataSrc !== 'url') {
            const values = component.values;
            if (values) {
                return values.findIndex(({ value: optionValue }) => optionValue === value) !== -1
                    ? null
                    : error;
            }
            return null;
        }
        else if (isValidateableSelectComponent(component)) {
            const values = getAvailableSelectValuesSync(component, context);
            if (values) {
                if ((0, util_1.isObject)(value)) {
                    return values.find((optionValue) => compareComplexValues(optionValue, value, context)) !==
                        undefined
                        ? null
                        : error;
                }
                return values.find((optionValue) => optionValue === value) !== undefined ? null : error;
            }
        }
        else if (isValidateableSelectBoxesComponent(component) && component.dataSrc !== 'url') {
            if (value == null || (0, lodash_1.isEmpty)(value) || !(0, util_1.isObject)(value)) {
                return null;
            }
            const values = component.values.map((val) => val.value);
            if (values) {
                return (0, lodash_1.difference)(Object.keys(value), values).length ? error : null;
            }
        }
    }
    catch (err) {
        throw new error_1.ProcessorError(err.message || err, context, 'validate:validateAvailableItems');
    }
    return null;
};
exports.validateAvailableItemsSync = validateAvailableItemsSync;
exports.validateAvailableItemsInfo = {
    name: 'validateAvailableItems',
    process: exports.validateAvailableItems,
    processSync: exports.validateAvailableItemsSync,
    shouldProcess: exports.shouldValidate,
};
