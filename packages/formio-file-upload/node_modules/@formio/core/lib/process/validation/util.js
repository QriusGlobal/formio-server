"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.doesArrayDataHaveValue = exports.hasValue = exports.interpolateErrors = exports.isObject = exports.isPromise = exports.toBoolean = exports.isEmptyObject = exports.isComponentProtected = exports.isComponentPersistent = void 0;
const utils_1 = require("../../utils");
const i18n_1 = require("./i18n");
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const isObject_1 = __importDefault(require("lodash/isObject"));
const isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
function isComponentPersistent(component) {
    return component.persistent ? component.persistent : true;
}
exports.isComponentPersistent = isComponentPersistent;
function isComponentProtected(component) {
    return component.protected ? component.protected : false;
}
exports.isComponentProtected = isComponentProtected;
function isEmptyObject(obj) {
    return !!obj && Object.keys(obj).length === 0 && obj.constructor === Object;
}
exports.isEmptyObject = isEmptyObject;
function toBoolean(value) {
    switch (typeof value) {
        case 'string':
            if (value === 'true' || value === '1') {
                return true;
            }
            else if (value === 'false' || value === '0') {
                return false;
            }
            else {
                throw `Cannot coerce string ${value} to boolean}`;
            }
        case 'boolean':
            return value;
        default:
            return !!value;
    }
}
exports.toBoolean = toBoolean;
function isPromise(value) {
    return (value &&
        value.then &&
        typeof value.then === 'function' &&
        Object.prototype.toString.call(value) === '[object Promise]');
}
exports.isPromise = isPromise;
function isObject(obj) {
    return obj != null && (typeof obj === 'object' || typeof obj === 'function');
}
exports.isObject = isObject;
const getCustomErrorMessage = ({ errorKeyOrMessage, context }) => { var _a, _b; return ((_b = (_a = context.component) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[errorKeyOrMessage]) || ''; };
/**
 * Interpolates @formio/core errors so that they are compatible with the renderer
 * @param {FieldError[]} errors
 * @param firstPass
 * @returns {[]}
 */
const interpolateErrors = (errors, lang = 'en') => {
    return errors.map((error) => {
        const { errorKeyOrMessage, context } = error;
        const i18n = i18n_1.VALIDATION_ERRORS[lang] || {};
        const toInterpolate = getCustomErrorMessage(error) || i18n[errorKeyOrMessage] || errorKeyOrMessage;
        const paths = [];
        context.path.split('.').forEach((part) => {
            const match = part.match(/\[([0-9]+)\]$/);
            if (match) {
                paths.push(part.substring(0, match.index));
                paths.push(parseInt(match[1]));
            }
            else {
                paths.push(part);
            }
        });
        return {
            message: (0, utils_1.unescapeHTML)(utils_1.Evaluator.interpolateString(toInterpolate, context)),
            level: error.level,
            path: paths,
            context: {
                validator: error.ruleName,
                hasLabel: context.hasLabel,
                key: context.component.key,
                label: context.component.label || context.component.placeholder || context.component.key,
                path: context.path,
                value: context.value,
                setting: context.setting,
                index: context.index || 0,
            },
        };
    });
};
exports.interpolateErrors = interpolateErrors;
const hasValue = (value) => {
    if ((0, isObject_1.default)(value)) {
        return !(0, isEmpty_1.default)(value);
    }
    return (typeof value === 'number' && !Number.isNaN(value)) || !!value;
};
exports.hasValue = hasValue;
const doesArrayDataHaveValue = (dataValue = []) => {
    if (!Array.isArray(dataValue)) {
        return !!dataValue;
    }
    if (!dataValue.length) {
        return false;
    }
    const isArrayDataComponent = dataValue.every(isPlainObject_1.default);
    if (isArrayDataComponent) {
        return dataValue.some((value) => Object.values(value).some(exports.hasValue));
    }
    return dataValue.some(exports.hasValue);
};
exports.doesArrayDataHaveValue = doesArrayDataHaveValue;
