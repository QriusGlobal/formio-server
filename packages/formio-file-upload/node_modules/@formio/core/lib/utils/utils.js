"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.interpolate = exports.evaluate = exports.attachResourceToDom = exports.unescapeHTML = exports.boolValue = exports.escapeRegExCharacters = void 0;
const lodash_1 = require("lodash");
const Evaluator_1 = require("./Evaluator");
const formUtil_1 = require("./formUtil");
/**
 * Escapes RegEx characters in provided String value.
 *
 * @param {String} value
 *   String for escaping RegEx characters.
 * @returns {string}
 *   String with escaped RegEx characters.
 */
function escapeRegExCharacters(value) {
    return value.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
}
exports.escapeRegExCharacters = escapeRegExCharacters;
/**
 * Determines the boolean value of a setting.
 *
 * @param value
 * @return {boolean}
 */
function boolValue(value) {
    if ((0, lodash_1.isBoolean)(value)) {
        return value;
    }
    else if ((0, lodash_1.isString)(value)) {
        return value.toLowerCase() === 'true';
    }
    else {
        return !!value;
    }
}
exports.boolValue = boolValue;
/**
 * Unescape HTML characters like &lt, &gt, &amp and etc.
 * @param str
 * @returns {string}
 */
function unescapeHTML(str) {
    if (typeof window === 'undefined' || !('DOMParser' in window)) {
        return str;
    }
    const doc = new window.DOMParser().parseFromString(str, 'text/html');
    return doc.documentElement.textContent;
}
exports.unescapeHTML = unescapeHTML;
function attachResourceToDom(options) {
    const { name, formio, onload, rootElement } = options;
    let { src } = options;
    src = Array.isArray(src) ? src : [src];
    src.forEach((lib) => {
        let attrs = {};
        let elementType = '';
        if (typeof lib === 'string') {
            lib = {
                type: 'script',
                src: lib,
            };
        }
        switch (lib.type) {
            case 'script':
                elementType = 'script';
                attrs = {
                    src: lib.src,
                    type: 'text/javascript',
                    defer: true,
                    async: true,
                    referrerpolicy: 'origin',
                };
                break;
            case 'styles':
                elementType = 'link';
                attrs = {
                    href: lib.src,
                    rel: 'stylesheet',
                };
                break;
        }
        // Add the script to the top of the page.
        const element = document.createElement(elementType);
        if (element.setAttribute) {
            for (const attr in attrs) {
                element.setAttribute(attr, attrs[attr]);
            }
        }
        if (onload) {
            element.addEventListener('load', () => {
                formio.libraries[name].loaded = true;
                onload(formio.libraries[name].ready);
            });
        }
        if (rootElement) {
            rootElement.insertAdjacentElement('afterend', element);
            return;
        }
        const { head } = document;
        if (head) {
            head.appendChild(element);
        }
    });
}
exports.attachResourceToDom = attachResourceToDom;
/**
 * A convenience function that wraps Evaluator.evaluate and normalizes context values
 * @param evaluation - The code string to evaluate
 * @param context - The processor context
 * @param ret - The return value
 * @param interpolate - Whether or not to interpolate the code string before evaluating
 * @param evalContextFn - A callback to mutate the context value after it has been normalized
 * @param options - Options to pass to the Evaluator
 * @returns {*} - Returns the result of the evaluation
 */
function evaluate(evaluation, context, ret = 'result', interpolate = false, evalContextFn, options = {}) {
    const { instance, form } = context;
    const normalizedContext = (0, formUtil_1.normalizeContext)(context);
    if (evalContextFn) {
        evalContextFn(normalizedContext);
    }
    if (form === null || form === void 0 ? void 0 : form.module) {
        options = Object.assign(Object.assign({}, options), { formModule: form.module });
    }
    if (instance && instance.evaluate) {
        return instance.evaluate(evaluation, normalizedContext, ret, interpolate, options);
    }
    return Evaluator_1.Evaluator.evaluate(evaluation, normalizedContext, ret, interpolate, context, options);
}
exports.evaluate = evaluate;
function interpolate(evaluation, context, evalContextFn) {
    const { instance } = context;
    const normalizedContext = (0, formUtil_1.normalizeContext)(context);
    if (evalContextFn) {
        evalContextFn(normalizedContext);
    }
    if (instance && instance.interpolate) {
        return instance.interpolate(evaluation, normalizedContext, {
            noeval: true,
        });
    }
    return Evaluator_1.Evaluator.interpolate(evaluation, normalizedContext, {
        noeval: true,
    });
}
exports.interpolate = interpolate;
