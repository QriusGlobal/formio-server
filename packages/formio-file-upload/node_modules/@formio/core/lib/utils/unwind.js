"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwind = exports.rewind = exports.mergeArray = exports.mergeObject = void 0;
const lodash_1 = require("lodash");
const fastCloneDeep_1 = require("./fastCloneDeep");
const formUtil_1 = require("./formUtil");
function mergeObject(src, dst) {
    (0, lodash_1.each)(src, function (value, key) {
        if (!Array.isArray(value)) {
            dst[key] = value;
        }
        else {
            if (!dst[key]) {
                dst[key] = [];
            }
            mergeArray(value, dst[key]);
        }
    });
}
exports.mergeObject = mergeObject;
function mergeArray(src, dst) {
    src.forEach(function (value) {
        const query = {};
        (0, lodash_1.each)(value, function (subValue, key) {
            if (!Array.isArray(subValue)) {
                query[key] = subValue;
            }
        });
        const dstValue = (0, lodash_1.find)(dst, query);
        if (dstValue) {
            mergeObject(value, dstValue);
        }
        else {
            dst.push(value);
        }
    });
}
exports.mergeArray = mergeArray;
function rewind(submissions) {
    const submission = { data: {} };
    if (submissions && submissions.length) {
        submissions.forEach((sub) => mergeObject(sub.data, submission.data));
    }
    return submission;
}
exports.rewind = rewind;
/**
 * @deprecated This method is no longer supported
 */
function unwind(form, submission) {
    const dataPaths = {};
    const locked = {};
    const submissions = [(0, fastCloneDeep_1.fastCloneDeep)(submission)];
    // Set the data value for a data path.
    const setDataValue = function (dataPath, values, parent, offset, current) {
        offset = offset || 0;
        current = current || 0;
        // Make sure we don't overwrite any locked values.
        while ((0, lodash_1.has)(locked, '[' + current + '].' + parent)) {
            if (current + 1 >= submissions.length) {
                submissions.push((0, fastCloneDeep_1.fastCloneDeep)(submissions[current]));
            }
            current++;
        }
        // Ensure that all parents have been copied over to this path.
        /* eslint-disable no-useless-escape */
        const parentPath = parent.replace(/\.[^\.]+$/, '');
        if (!(0, lodash_1.has)(submissions[current].data, parentPath) &&
            submissions[current - 1] &&
            (0, lodash_1.has)(submissions[current - 1].data, parentPath)) {
            (0, lodash_1.set)(submissions[current].data, parentPath, (0, fastCloneDeep_1.fastCloneDeep)((0, lodash_1.get)(submissions[current - 1].data, parentPath)));
        }
        /* eslint-enable no-useless-escape */
        const pathValue = [];
        (0, lodash_1.set)(submissions[current].data, parent, pathValue);
        (0, lodash_1.set)(locked, '[' + current + '].' + parent, true);
        for (let i = offset; i < values.length; i++) {
            if (i - offset <= dataPath.max) {
                pathValue.push(values[i]);
                if (dataPath.paths && Object.keys(dataPath.paths).length) {
                    addData(dataPath.paths, values[i], parent + '[' + (i - offset) + ']', current);
                }
            }
            else {
                setDataValue(dataPath, values, parent, i, current);
                break;
            }
        }
    };
    // Add data to a series of data paths.
    const addData = function (dataPaths, data, parent, current) {
        for (const path in dataPaths) {
            const dataPath = dataPaths[path];
            if (data[path] && Array.isArray(data[path])) {
                setDataValue(dataPath, data[path], parent ? parent + '.' + path : path, 0, current);
            }
        }
    };
    const addDataPaths = function (dataPath, paths, index, parentDataPath) {
        index = index || 0;
        const path = paths[index];
        /* eslint-disable no-useless-escape */
        const matches = path.match(/([^\[]+)\[?([0-9]+)?\]?/);
        /* eslint-enable no-useless-escape */
        if (matches && matches.length === 3) {
            const dataParam = matches[1];
            const dataIndex = parseInt(matches[2], 10) || 0;
            if (dataPath[dataParam]) {
                if (dataIndex > dataPath[dataParam].max) {
                    dataPath[dataParam].max = dataIndex;
                }
            }
            else {
                dataPath[dataParam] = {
                    max: dataIndex,
                    param: dataParam,
                    parent: parentDataPath || null,
                    paths: {},
                };
            }
            if (index + 1 < paths.length) {
                addDataPaths(dataPath[dataParam].paths, paths, index + 1, dataPath[dataParam]);
            }
        }
    };
    // Iterate through all components.
    (0, formUtil_1.eachComponent)(form.components, function (component, path) {
        var _a;
        if (component.type === 'form' && ((_a = component.components) === null || _a === void 0 ? void 0 : _a.length)) {
            (0, formUtil_1.eachComponent)(component.components, (comp) => {
                comp.isInsideNestedForm = true;
            });
        }
        if (!component.overlay || (!component.overlay.width && !component.overlay.height)) {
            return;
        }
        const hasDataPath = component.properties && component.properties.dataPath;
        let key = component.key;
        if (hasDataPath) {
            path = component.properties.dataPath;
            key = component.properties.dataPath;
        }
        const paths = (0, lodash_1.filter)(path.replace(new RegExp('.?' + component.key + '$'), '').split('.'));
        if (!hasDataPath && paths.length && !component.isInsideNestedForm) {
            key = paths.join('.') + '.' + component.key;
        }
        if (component.multiple) {
            paths.push(component.key);
        }
        component.key = key;
        if (paths && paths.length) {
            addDataPaths(dataPaths, paths);
        }
    }, true);
    addData(dataPaths, submission.data);
    return submissions;
}
exports.unwind = unwind;
