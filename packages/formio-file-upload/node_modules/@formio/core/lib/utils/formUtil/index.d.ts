import { HasChildComponents, Component, DataObject, SelectComponent, ComponentScope, ComponentPaths, ComponentPath, Form, ValidationContext } from '../../types';
import { eachComponent } from './eachComponent';
import { eachComponentData } from './eachComponentData';
import { eachComponentAsync } from './eachComponentAsync';
import { eachComponentDataAsync } from './eachComponentDataAsync';
/**
 * Flatten the form components for data manipulation.
 *
 * @param {Object} components
 *   The components to iterate.
 * @param {Boolean} includeAll
 *   Whether or not to include layout components.
 *
 * @returns {Object}
 *   The flattened components map.
 */
export declare function flattenComponents(components: Component[], includeAll?: boolean): any;
export declare function guid(): string;
/**
 * Make a filename guaranteed to be unique.
 * @param name
 * @param template
 * @param evalContext
 * @returns {string}
 */
export declare function uniqueName(name: string, template?: string, evalContext?: any): string;
/**
 * Defines model types for known components.
 * For now, these will be the only model types supported by the @formio/core library.
 *
 * nestedArray: for components that store their data as an array and have nested components.
 * nestedDataArray: for components that store their data as an array and have nested components, but keeps the value of nested components inside 'data' property.
 * array: for components that store their data as an array.
 * dataObject: for components that store their data in a nested { data: {} } object.
 * object: for components that store their data in an object.
 * map: for components that store their data in a map.
 * content: for components that do not store data.
 * string: for components that store their data as a string.
 * number: for components that store their data as a number.
 * boolean: for components that store their data as a boolean.
 * none: for components that do not store data and should not be included in the submission.
 * any: for components that can store any type of data.
 *
 */
export declare const MODEL_TYPES_OF_KNOWN_COMPONENTS: {
    nestedArray: string[];
    nestedDataArray: string[];
    dataObject: string[];
    object: string[];
    map: string[];
    content: string[];
    string: string[];
    number: string[];
    boolean: string[];
    none: string[];
    any: string[];
};
export declare function getModelType(component: Component): keyof typeof MODEL_TYPES_OF_KNOWN_COMPONENTS;
export declare function isComponentNestedDataType(component: any): component is HasChildComponents;
export declare function setComponentScope(component: Component, name: keyof NonNullable<ComponentScope>, value: string | boolean | number): void;
export declare function resetComponentScope(component: Component): void;
/**
 * Return the component path provided the type of the component path.
 * @param component - The component JSON.
 * @param type - The type of path to return.
 * @returns
 */
export declare function componentPath(component: Component, parent: Component | undefined | null, parentPaths: ComponentPaths | undefined | null, type: ComponentPath): string;
/**
 * This method determines a components paths provided the component JSON, the parent and the parent paths.
 * @param component
 * @param parent
 * @param parentPaths
 * @returns
 */
export declare function getComponentPaths(component: Component, parent?: Component, parentPaths?: ComponentPaths): ComponentPaths;
export declare function getStringFromComponentPath(path: string | string[]): string;
export type ComponentMatch = {
    component: Component | undefined;
    paths: ComponentPaths | undefined;
};
/**
 * Determines if a component has a match at any of the path types.
 * @param component {Component} - The component JSON to check for matches.
 * @param paths {ComponentPaths} - The current component paths object.
 * @param path {string} - Either the "form" or "data" path to see if a match occurs.
 * @param dataIndex {number | undefined} - The data index for the current component to match.
 * @param matches {Record<string, ComponentMatch | undefined>} - The current matches object.
 * @param addMatch {(type: ComponentPath | 'key', match: ComponentMatch) => ComponentMatch} - A callback function to allow modules to decorate the match object.
 */
export declare function componentMatches(component: Component, paths: ComponentPaths, path: string, dataIndex?: number, matches?: Record<string, ComponentMatch | undefined>, addMatch?: (type: ComponentPath | 'key', match: ComponentMatch) => ComponentMatch): void;
export declare function getBestMatch(matches: Record<string, ComponentMatch | undefined>): ComponentMatch | undefined;
/**
 * This method performs a fuzzy search for a component within a form provided a number of different
 * paths to search.
 */
export declare function getComponentFromPath(components: Component[], path: any, data?: any, dataIndex?: number, includeAll?: any): ComponentMatch | undefined;
/**
 * Provided a component, this will return the "data" key for that component in the contextual data
 * object.
 *
 * @param component
 * @returns
 */
export declare function getComponentKey(component: Component): string;
export declare function getContextualRowData(component: Component, data: any, paths?: ComponentPaths, local?: boolean): any;
export declare function getComponentLocalData(paths: ComponentPaths, data: any, local?: boolean): string;
export declare function shouldProcessComponent(comp: Component, value: any, paths?: ComponentPaths): boolean;
export declare function componentInfo(component: any): {
    hasColumns: any;
    hasRows: any;
    hasComps: any;
    layout: any;
    iterable: any;
};
export declare function getComponentData(components: Component[], data: DataObject, path: string): any;
export declare function getComponentValue(form: Form | undefined, data: DataObject, path: string, dataIndex?: number, local?: boolean): unknown;
/**
 * Determine if a component is a layout component or not.
 *
 * @param {Object} component
 *   The component to check.
 *
 * @returns {Boolean}
 *   Whether or not the component is a layout component.
 */
export declare function isLayoutComponent(component: Component): boolean;
/**
 * Matches if a component matches the query.
 *
 * @param component
 * @param query
 * @return {boolean}
 */
export declare function matchComponent(component: Component, query: any, paths?: ComponentPaths): boolean;
/**
 * Get a component by its path.
 *
 * @param {Object} components - The components to iterate.
 * @param {String|Object} path - The key of the component to get, or a query of the component to search.
 * @param {boolean} includeAll - Whether or not to include layout components.
 * @returns {Component} - The component that matches the given key, or undefined if not found.
 */
export declare function getComponent(components: Component[], path: any, includeAll?: any, dataIndex?: number): Component | undefined;
/**
 * Finds a component provided a query of properties of that component.
 *
 * @param components
 * @param query
 * @return {*}
 */
export declare function searchComponents(components: Component[], query: any): Component[];
/**
 * Deprecated version of findComponents. Renamed to searchComponents.
 * @param {import('@formio/core').Component[]} components - The components to find components within.
 * @param {object} query - The query to use when searching for the components.
 * @returns {import('@formio/core').Component[]} - The result of the component that is found.
 */
export declare function findComponents(components: Component[], query: any): Component[];
/**
 * Remove a component by path.
 *
 * @param components
 * @param path
 */
export declare function removeComponent(components: Component[], path: string): void;
/**
 * Returns if this component has a conditional statement.
 *
 * @param component - The component JSON schema.
 *
 * @returns {boolean} - TRUE - This component has a conditional, FALSE - No conditional provided.
 */
export declare function hasCondition(component: Component): boolean;
/**
 * Extension of standard #parseFloat(value) function, that also clears input string.
 *
 * @param {any} value
 *   The value to parse.
 *
 * @returns {Number}
 *   Parsed value.
 */
export declare function parseFloatExt(value: any): number;
/**
 * Formats provided value in way how Currency component uses it.
 *
 * @param {any} value
 *   The value to format.
 *
 * @returns {String}
 *   Value formatted for Currency component.
 */
export declare function formatAsCurrency(value: string): string;
/**
 * Escapes RegEx characters in provided String value.
 *
 * @param {String} value
 *   String for escaping RegEx characters.
 * @returns {string}
 *   String with escaped RegEx characters.
 */
export declare function escapeRegExCharacters(value: string): string;
/**
 * Get the value for a component key, in the given submission.
 *
 * @param {Object} submission
 *   A submission object to search.
 * @param {String} key
 *   A for components API key to search for.
 */
export declare function getValue(submission: any, key: string): any;
/**
 * Iterate over all components in a form and get string values for translation.
 * @param form
 */
export declare function getStrings(form: any): any;
export declare function generateFormChange(type: any, data: any): {
    op: string;
    key: any;
    container: any;
    path: any;
    index: any;
    component: any;
    patches?: undefined;
} | {
    op: string;
    key: any;
    patches: import("fast-json-patch").Operation[];
    container?: undefined;
    path?: undefined;
    index?: undefined;
    component?: undefined;
} | {
    op: string;
    key: any;
    container?: undefined;
    path?: undefined;
    index?: undefined;
    component?: undefined;
    patches?: undefined;
} | null | undefined;
export declare function applyFormChanges(form: any, changes: any): {
    form: any;
    failed: any;
};
/**
 * This function will find a component in a form and return the component AND THE PATH to the component in the form.
 * Path to the component is stored as an array of nested components and their indexes.The Path is being filled recursively
 * when you iterating through the nested structure.
 * If the component is not found the callback won't be called and function won't return anything.
 *
 * @param components
 * @param key
 * @param fn
 * @param path
 * @returns {*}
 */
export declare function findComponent(components: any, key: any, path: any, fn: any): any;
export declare function getEmptyValue(component: Component): "" | never[] | null;
export declare function isComponentDataEmpty(component: Component, data: any, path: string, valueCond?: any): boolean;
/**
 * Returns the template keys inside the template code.
 * @param {string} template - The template to get the keys from.
 * @returns {Array<string>} - The keys inside the template.
 */
export declare function getItemTemplateKeys(template: any): string[];
/**
 * Returns if the component is a select resource with an object for its value.
 * @param {Component} comp - The component to check.
 * @returns {boolean} - TRUE if the component is a select resource with an object for its value; FALSE otherwise.
 */
export declare function isSelectResourceWithObjectValue(comp?: any): any;
/**
 * Compares real select resource value with expected value in condition.
 * @param {any} value - current value of selectcomponent.
 * @param {any} comparedValue - expocted value of select component.
 * @param {SelectComponent} conditionComponent - select component on which the condtion is based.
 * @returns {boolean} - TRUE if the select component current value is equal to the expected value; FALSE otherwise.
 */
export declare function compareSelectResourceWithObjectTypeValues(value: any, comparedValue: any, conditionComponent: SelectComponent): boolean;
export declare function getComponentErrorField(component: Component, context: ValidationContext): any;
/**
 * Normalize a context object so that it contains the correct paths and data, and so it can pass into and out of a sandbox for evaluation
 * @param context
 * @returns
 */
export declare function normalizeContext(context: any): any;
export { eachComponent, eachComponentData, eachComponentAsync, eachComponentDataAsync };
