"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eachComponentDataAsync = exports.eachComponentAsync = exports.eachComponentData = exports.eachComponent = exports.normalizeContext = exports.getComponentErrorField = exports.compareSelectResourceWithObjectTypeValues = exports.isSelectResourceWithObjectValue = exports.getItemTemplateKeys = exports.isComponentDataEmpty = exports.getEmptyValue = exports.findComponent = exports.applyFormChanges = exports.generateFormChange = exports.getStrings = exports.getValue = exports.escapeRegExCharacters = exports.formatAsCurrency = exports.parseFloatExt = exports.hasCondition = exports.removeComponent = exports.findComponents = exports.searchComponents = exports.getComponent = exports.matchComponent = exports.isLayoutComponent = exports.getComponentValue = exports.getComponentData = exports.componentInfo = exports.shouldProcessComponent = exports.getComponentLocalData = exports.getContextualRowData = exports.getComponentKey = exports.getComponentFromPath = exports.getBestMatch = exports.componentMatches = exports.getStringFromComponentPath = exports.getComponentPaths = exports.componentPath = exports.resetComponentScope = exports.setComponentScope = exports.isComponentNestedDataType = exports.getModelType = exports.MODEL_TYPES_OF_KNOWN_COMPONENTS = exports.uniqueName = exports.guid = exports.flattenComponents = void 0;
const lodash_1 = require("lodash");
const fast_json_patch_1 = require("fast-json-patch");
const types_1 = require("../../types");
const Evaluator_1 = require("../Evaluator");
const eachComponent_1 = require("./eachComponent");
Object.defineProperty(exports, "eachComponent", { enumerable: true, get: function () { return eachComponent_1.eachComponent; } });
const eachComponentData_1 = require("./eachComponentData");
Object.defineProperty(exports, "eachComponentData", { enumerable: true, get: function () { return eachComponentData_1.eachComponentData; } });
const eachComponentAsync_1 = require("./eachComponentAsync");
Object.defineProperty(exports, "eachComponentAsync", { enumerable: true, get: function () { return eachComponentAsync_1.eachComponentAsync; } });
const eachComponentDataAsync_1 = require("./eachComponentDataAsync");
Object.defineProperty(exports, "eachComponentDataAsync", { enumerable: true, get: function () { return eachComponentDataAsync_1.eachComponentDataAsync; } });
/**
 * Flatten the form components for data manipulation.
 *
 * @param {Object} components
 *   The components to iterate.
 * @param {Boolean} includeAll
 *   Whether or not to include layout components.
 *
 * @returns {Object}
 *   The flattened components map.
 */
function flattenComponents(components, includeAll = false) {
    const flattened = {};
    (0, eachComponent_1.eachComponent)(components, (component, path) => {
        flattened[path] = component;
    }, includeAll);
    return flattened;
}
exports.flattenComponents = flattenComponents;
function guid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
exports.guid = guid;
/**
 * Make a filename guaranteed to be unique.
 * @param name
 * @param template
 * @param evalContext
 * @returns {string}
 */
function uniqueName(name, template, evalContext) {
    template = template || '{{fileName}}-{{guid}}';
    //include guid in template anyway, to prevent overwriting issue if filename matches existing file
    if (!template.includes('{{guid}}')) {
        template = `${template}-{{guid}}`;
    }
    const parts = name.split('.');
    let fileName = parts.slice(0, parts.length - 1).join('.');
    const extension = parts.length > 1 ? `.${(0, lodash_1.last)(parts)}` : '';
    //allow only 100 characters from original name to avoid issues with filename length restrictions
    fileName = fileName.substr(0, 100);
    evalContext = Object.assign(evalContext || {}, {
        fileName,
        guid: guid(),
    });
    //only letters, numbers, dots, dashes, underscores and spaces are allowed. Anything else will be replaced with dash
    const uniqueName = `${Evaluator_1.Evaluator.interpolate(template, evalContext)}${extension}`.replace(/[^0-9a-zA-Z.\-_ ]/g, '-');
    return uniqueName;
}
exports.uniqueName = uniqueName;
/**
 * Defines model types for known components.
 * For now, these will be the only model types supported by the @formio/core library.
 *
 * nestedArray: for components that store their data as an array and have nested components.
 * nestedDataArray: for components that store their data as an array and have nested components, but keeps the value of nested components inside 'data' property.
 * array: for components that store their data as an array.
 * dataObject: for components that store their data in a nested { data: {} } object.
 * object: for components that store their data in an object.
 * map: for components that store their data in a map.
 * content: for components that do not store data.
 * string: for components that store their data as a string.
 * number: for components that store their data as a number.
 * boolean: for components that store their data as a boolean.
 * none: for components that do not store data and should not be included in the submission.
 * any: for components that can store any type of data.
 *
 */
exports.MODEL_TYPES_OF_KNOWN_COMPONENTS = {
    nestedArray: ['datagrid', 'editgrid', 'datatable', 'dynamicWizard'],
    nestedDataArray: ['tagpad'],
    dataObject: ['form'],
    object: ['container', 'address'],
    map: ['datamap'],
    content: ['htmlelement', 'content'],
    string: [
        'textfield',
        'password',
        'email',
        'url',
        'phoneNumber',
        'day',
        'datetime',
        'time',
        'signature',
    ],
    number: ['number', 'currency'],
    boolean: ['checkbox', 'radio'],
    none: ['table', 'well', 'columns', 'fieldset', 'panel', 'tabs'],
    any: [
        'survey',
        'captcha',
        'textarea',
        'selectboxes',
        'tags',
        'select',
        'hidden',
        'button',
        'datasource',
        'sketchpad',
        'reviewpage',
        'file',
    ],
};
function getModelType(component) {
    // If the component JSON asserts a model type, use that.
    if (component.modelType) {
        return component.modelType;
    }
    let modelType = 'any';
    // Otherwise, check for known component types.
    for (const type of Object.keys(exports.MODEL_TYPES_OF_KNOWN_COMPONENTS)) {
        if (exports.MODEL_TYPES_OF_KNOWN_COMPONENTS[type].includes(component.type)) {
            modelType = type;
            break;
        }
    }
    // Otherwise check for components that assert no value.
    if (modelType === 'any' &&
        (component.input === false ||
            (component.components && !component.input))) {
        modelType = 'none';
    }
    // To speed up performance of getModelType, we will set the modelType on the component
    Object.defineProperty(component, 'modelType', {
        enumerable: false,
        writable: true,
        value: modelType,
    });
    // Otherwise default to any.
    return modelType;
}
exports.getModelType = getModelType;
function isComponentNestedDataType(component) {
    return (component.tree ||
        getModelType(component) === 'nestedArray' ||
        getModelType(component) === 'nestedDataArray' ||
        getModelType(component) === 'dataObject' ||
        getModelType(component) === 'object' ||
        getModelType(component) === 'map');
}
exports.isComponentNestedDataType = isComponentNestedDataType;
function setComponentScope(component, name, value) {
    if (!component) {
        return;
    }
    if (!component.scope) {
        Object.defineProperty(component, 'scope', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: {},
        });
    }
    Object.defineProperty(component.scope, name, {
        enumerable: false,
        writable: false,
        configurable: true,
        value,
    });
}
exports.setComponentScope = setComponentScope;
function resetComponentScope(component) {
    if (component.scope) {
        delete component.scope;
    }
}
exports.resetComponentScope = resetComponentScope;
/**
 * Return the component path provided the type of the component path.
 * @param component - The component JSON.
 * @param type - The type of path to return.
 * @returns
 */
function componentPath(component, parent, parentPaths, type) {
    if (!component) {
        return '';
    }
    if (component.component) {
        component = component.component;
    }
    const compModel = getModelType(component);
    // Relative paths are only referenced from the current form.
    const relative = type === types_1.ComponentPath.localPath ||
        type === types_1.ComponentPath.fullLocalPath ||
        type === types_1.ComponentPath.localDataPath ||
        type === types_1.ComponentPath.localContextualRowPath;
    // Full paths include all layout component ids in the path.
    const fullPath = type === types_1.ComponentPath.fullPath || type === types_1.ComponentPath.fullLocalPath;
    // See if this is a data path.
    const dataPath = type === types_1.ComponentPath.dataPath ||
        type === types_1.ComponentPath.localDataPath ||
        type === types_1.ComponentPath.contextualRowPath ||
        type === types_1.ComponentPath.localContextualRowPath;
    // Determine if this component should include its key.
    const includeKey = fullPath || (!!component.type && compModel !== 'none' && compModel !== 'content');
    // The key is provided if the component can have data or if we are fetching the full path.
    const key = includeKey ? getComponentKey(component) : '';
    // If this is a contextual row path.
    const contextual = type === types_1.ComponentPath.contextualRowPath || type === types_1.ComponentPath.localContextualRowPath;
    if (!parent) {
        // Return the key if there is no parent.
        return contextual ? '' : key;
    }
    // Get the parent model type.
    const parentModel = getModelType(parent);
    // If there is a parent, then we only return the key if the parent is a nested form and it is a relative path.
    if (relative && parentModel === 'dataObject') {
        return contextual ? '' : key;
    }
    // Return the parent path.
    const parentType = contextual
        ? relative
            ? types_1.ComponentPath.localDataPath
            : types_1.ComponentPath.dataPath
        : type;
    let parentPath = (parentPaths === null || parentPaths === void 0 ? void 0 : parentPaths.hasOwnProperty(parentType)) ? parentPaths[parentType] || '' : '';
    // For data paths (where we wish to get the path to the data), we need to ensure we append the parent
    // paths to the end of the path so that any component within this component properly references their data.
    if (dataPath && parentPath) {
        if (parentModel === 'nestedArray' || parentModel === 'nestedDataArray') {
            parentPath += `[${(parentPaths === null || parentPaths === void 0 ? void 0 : parentPaths.dataIndex) || 0}]`;
        }
        if (parentModel === 'dataObject' || parentModel === 'nestedDataArray') {
            parentPath += '.data';
        }
    }
    // If this is a contextual row path, then return here.
    if (contextual) {
        return parentPath;
    }
    // Return the parent path with its relative component path (if applicable).
    return parentPath ? (key ? `${parentPath}.${key}` : parentPath) : key;
}
exports.componentPath = componentPath;
/**
 * This method determines a components paths provided the component JSON, the parent and the parent paths.
 * @param component
 * @param parent
 * @param parentPaths
 * @returns
 */
function getComponentPaths(component, parent, parentPaths) {
    return {
        path: componentPath(component, parent, parentPaths, types_1.ComponentPath.path),
        fullPath: componentPath(component, parent, parentPaths, types_1.ComponentPath.fullPath),
        localPath: componentPath(component, parent, parentPaths, types_1.ComponentPath.localPath),
        fullLocalPath: componentPath(component, parent, parentPaths, types_1.ComponentPath.fullLocalPath),
        dataPath: componentPath(component, parent, parentPaths, types_1.ComponentPath.dataPath),
        localDataPath: componentPath(component, parent, parentPaths, types_1.ComponentPath.localDataPath),
        dataIndex: parentPaths === null || parentPaths === void 0 ? void 0 : parentPaths.dataIndex,
        contextualRowPath: componentPath(component, parent, parentPaths, types_1.ComponentPath.contextualRowPath),
        localContextualRowPath: componentPath(component, parent, parentPaths, types_1.ComponentPath.localContextualRowPath),
    };
}
exports.getComponentPaths = getComponentPaths;
function getStringFromComponentPath(path) {
    if (!(0, lodash_1.isArray)(path)) {
        return path;
    }
    let strPath = '';
    path.forEach((part, i) => {
        if ((0, lodash_1.isNumber)(part)) {
            strPath += `[${part}]`;
        }
        else {
            strPath += i === 0 ? part : `.${part}`;
        }
    });
    return strPath;
}
exports.getStringFromComponentPath = getStringFromComponentPath;
/**
 * Determines if a component has a match at any of the path types.
 * @param component {Component} - The component JSON to check for matches.
 * @param paths {ComponentPaths} - The current component paths object.
 * @param path {string} - Either the "form" or "data" path to see if a match occurs.
 * @param dataIndex {number | undefined} - The data index for the current component to match.
 * @param matches {Record<string, ComponentMatch | undefined>} - The current matches object.
 * @param addMatch {(type: ComponentPath | 'key', match: ComponentMatch) => ComponentMatch} - A callback function to allow modules to decorate the match object.
 */
function componentMatches(component, paths, path, dataIndex, matches = {
    path: undefined,
    fullPath: undefined,
    localPath: undefined,
    dataPath: undefined,
    localDataPath: undefined,
    fullLocalPath: undefined,
    key: undefined,
}, addMatch = (type, match) => {
    return match;
}) {
    let dataProperty = '';
    if (component.type === 'selectboxes') {
        const valuePath = new RegExp(`(\\.${(0, lodash_1.escapeRegExp)(component.key)})(\\.[^\\.]+)$`);
        const pathMatches = path.match(valuePath);
        if ((pathMatches === null || pathMatches === void 0 ? void 0 : pathMatches.length) === 3) {
            dataProperty = pathMatches[2];
            path = path.replace(valuePath, '$1');
        }
    }
    // Get the current model type.
    const modelType = getModelType(component);
    const dataModel = modelType !== 'none' && modelType !== 'content';
    [
        types_1.ComponentPath.path,
        types_1.ComponentPath.fullPath,
        types_1.ComponentPath.localPath,
        types_1.ComponentPath.fullLocalPath,
        types_1.ComponentPath.dataPath,
        types_1.ComponentPath.localDataPath,
    ].forEach((type) => {
        const dataPath = type === types_1.ComponentPath.dataPath || type === types_1.ComponentPath.localDataPath;
        if (paths[type] === path) {
            const currentMatch = matches[type];
            const currentModelType = (currentMatch === null || currentMatch === void 0 ? void 0 : currentMatch.component)
                ? getModelType(currentMatch.component)
                : 'none';
            const currentDataModel = currentModelType !== 'none' && currentModelType !== 'content';
            if (!currentMatch ||
                (dataPath && dataModel && currentDataModel) || // Replace the current match if this is a dataPath and both are dataModels.
                (!dataPath && !(0, lodash_1.isNil)(paths.dataIndex) && dataIndex === paths.dataIndex) // Replace the current match if this is not a dataPath and the indexes are the same.
            ) {
                if (dataPath) {
                    const dataPaths = {
                        dataPath: paths.dataPath || '',
                        localDataPath: paths.localDataPath || '',
                    };
                    if (dataProperty) {
                        dataPaths.dataPath += dataProperty;
                        dataPaths.localDataPath += dataProperty;
                    }
                    matches[type] = addMatch(type, {
                        component,
                        paths: Object.assign(Object.assign({}, paths), dataPaths),
                    });
                }
                else {
                    matches[type] = addMatch(type, { component, paths });
                }
            }
        }
    });
    if (!matches.key && component.key === path) {
        matches.key = addMatch('key', { component, paths });
    }
}
exports.componentMatches = componentMatches;
function getBestMatch(matches) {
    if (matches.dataPath) {
        return matches.dataPath;
    }
    if (matches.localDataPath) {
        return matches.localDataPath;
    }
    if (matches.fullPath) {
        return matches.fullPath;
    }
    if (matches.path) {
        return matches.path;
    }
    if (matches.fullLocalPath) {
        return matches.fullLocalPath;
    }
    if (matches.localPath) {
        return matches.localPath;
    }
    if (matches.key) {
        return matches.key;
    }
    return undefined;
}
exports.getBestMatch = getBestMatch;
/**
 * This method performs a fuzzy search for a component within a form provided a number of different
 * paths to search.
 */
function getComponentFromPath(components, path, data, dataIndex, includeAll = false) {
    const matches = {
        path: undefined,
        fullPath: undefined,
        localPath: undefined,
        fullLocalPath: undefined,
        dataPath: undefined,
        localDataPath: undefined,
        key: undefined,
    };
    if (data) {
        (0, eachComponentData_1.eachComponentData)(components, data, (component, data, row, compPath, comps, index, parent, paths) => {
            componentMatches(component, paths || {}, path, dataIndex, matches);
        }, includeAll, false, undefined, undefined, true);
    }
    else {
        (0, eachComponent_1.eachComponent)(components, (component, compPath, componentComponents, compParent, paths) => {
            componentMatches(component, paths || {}, path, dataIndex, matches);
        }, includeAll);
    }
    return getBestMatch(matches);
}
exports.getComponentFromPath = getComponentFromPath;
/**
 * Provided a component, this will return the "data" key for that component in the contextual data
 * object.
 *
 * @param component
 * @returns
 */
function getComponentKey(component) {
    if (!component) {
        return '';
    }
    if (component.type === 'checkbox' &&
        component.inputType === 'radio' &&
        component.name) {
        return component.name;
    }
    return component.key;
}
exports.getComponentKey = getComponentKey;
function getContextualRowData(component, data, paths, local) {
    if ((paths === null || paths === void 0 ? void 0 : paths.hasOwnProperty('localContextualRowPath')) &&
        (paths === null || paths === void 0 ? void 0 : paths.hasOwnProperty('contextualRowPath'))) {
        const rowPath = local ? paths === null || paths === void 0 ? void 0 : paths.localContextualRowPath : paths === null || paths === void 0 ? void 0 : paths.contextualRowPath;
        return rowPath ? (0, lodash_1.get)(data, rowPath, null) : data;
    }
    // Fallback to the less performant regex method.
    const dataPath = local ? paths === null || paths === void 0 ? void 0 : paths.localDataPath : paths === null || paths === void 0 ? void 0 : paths.dataPath;
    const rowPath = (dataPath === null || dataPath === void 0 ? void 0 : dataPath.replace(new RegExp(`.?${(0, lodash_1.escapeRegExp)(getComponentKey(component))}$`), '')) || '';
    return rowPath ? (0, lodash_1.get)(data, rowPath, null) : data;
}
exports.getContextualRowData = getContextualRowData;
function getComponentLocalData(paths, data, local) {
    var _a;
    if (local) {
        return data;
    }
    const parentPath = ((_a = paths.dataPath) === null || _a === void 0 ? void 0 : _a.replace(new RegExp(`.?${(0, lodash_1.escapeRegExp)(paths.localDataPath)}$`), '')) || '';
    return parentPath ? (0, lodash_1.get)(data, parentPath, null) : data;
}
exports.getComponentLocalData = getComponentLocalData;
function shouldProcessComponent(comp, value, paths) {
    var _a;
    if (getModelType(comp) === 'dataObject') {
        const noReferenceAttached = (value === null || value === void 0 ? void 0 : value._id) ? (0, lodash_1.isEmpty)(value.data) && !(0, lodash_1.has)(value, 'form') : false;
        const shouldBeCleared = (!comp.hasOwnProperty('clearOnHide') || comp.clearOnHide) &&
            (comp.hidden || ((_a = comp.scope) === null || _a === void 0 ? void 0 : _a.conditionallyHidden));
        // Also skip processing if the value is empty and the form is in an array component.
        const emptyInDataGrid = !value && (paths === null || paths === void 0 ? void 0 : paths.dataIndex) !== undefined;
        const shouldSkipProcessingNestedFormData = noReferenceAttached || (shouldBeCleared && !comp.validateWhenHidden) || emptyInDataGrid;
        if (shouldSkipProcessingNestedFormData) {
            return false;
        }
    }
    return true;
}
exports.shouldProcessComponent = shouldProcessComponent;
function componentInfo(component) {
    const hasColumns = component.columns && Array.isArray(component.columns);
    const hasRows = component.rows && Array.isArray(component.rows);
    const hasComps = component.components && Array.isArray(component.components);
    const isContent = getModelType(component) === 'content';
    const isLayout = getModelType(component) === 'none';
    const isInput = (!component.hasOwnProperty('input') && !component.components) || !!component.input;
    return {
        hasColumns,
        hasRows,
        hasComps,
        layout: hasColumns || hasRows || (hasComps && !isInput) || isLayout || isContent,
        iterable: hasColumns || hasRows || hasComps || isContent,
    };
}
exports.componentInfo = componentInfo;
// Provided components, data, and a key, this will return the components data.
function getComponentData(components, data, path) {
    const compData = { component: null, data: null };
    (0, eachComponentData_1.eachComponentData)(components, data, (component, data, row, compPath) => {
        if (compPath === path) {
            compData.component = component;
            compData.data = row;
            return true;
        }
    });
    return compData;
}
exports.getComponentData = getComponentData;
function getComponentValue(form, data, path, dataIndex, local) {
    var _a, _b;
    const match = getComponentFromPath((form === null || form === void 0 ? void 0 : form.components) || [], path, data, dataIndex);
    if (!match) {
        // Fall back to get the value from the data object.
        return (0, lodash_1.get)(data, path, undefined);
    }
    if (local) {
        return ((_a = match === null || match === void 0 ? void 0 : match.paths) === null || _a === void 0 ? void 0 : _a.localDataPath) ? (0, lodash_1.get)(data, match.paths.localDataPath, undefined) : null;
    }
    return ((_b = match === null || match === void 0 ? void 0 : match.paths) === null || _b === void 0 ? void 0 : _b.dataPath) ? (0, lodash_1.get)(data, match.paths.dataPath, undefined) : null;
}
exports.getComponentValue = getComponentValue;
/**
 * Determine if a component is a layout component or not.
 *
 * @param {Object} component
 *   The component to check.
 *
 * @returns {Boolean}
 *   Whether or not the component is a layout component.
 */
function isLayoutComponent(component) {
    return Boolean((component.columns &&
        Array.isArray(component.columns)) ||
        (component.rows && Array.isArray(component.rows)) ||
        (component.components &&
            Array.isArray(component.components)));
}
exports.isLayoutComponent = isLayoutComponent;
/**
 * Matches if a component matches the query.
 *
 * @param component
 * @param query
 * @return {boolean}
 */
function matchComponent(component, query, paths) {
    if ((0, lodash_1.isString)(query)) {
        return component.key === query || (paths === null || paths === void 0 ? void 0 : paths.localPath) === query || (paths === null || paths === void 0 ? void 0 : paths.path) === query;
    }
    else {
        let matches = false;
        (0, lodash_1.forOwn)(query, (value, key) => {
            matches = (0, lodash_1.get)(component, key) === value;
            if (!matches) {
                return false;
            }
        });
        return matches;
    }
}
exports.matchComponent = matchComponent;
/**
 * Get a component by its path.
 *
 * @param {Object} components - The components to iterate.
 * @param {String|Object} path - The key of the component to get, or a query of the component to search.
 * @param {boolean} includeAll - Whether or not to include layout components.
 * @returns {Component} - The component that matches the given key, or undefined if not found.
 */
function getComponent(components, path, includeAll = true, dataIndex) {
    var _a;
    return (_a = getComponentFromPath(components, path, undefined, dataIndex, includeAll)) === null || _a === void 0 ? void 0 : _a.component;
}
exports.getComponent = getComponent;
/**
 * Finds a component provided a query of properties of that component.
 *
 * @param components
 * @param query
 * @return {*}
 */
function searchComponents(components, query) {
    const results = [];
    (0, eachComponent_1.eachComponent)(components, (component, compPath, components, parent, compPaths) => {
        if (matchComponent(component, query, compPaths)) {
            results.push(component);
        }
    }, true);
    return results;
}
exports.searchComponents = searchComponents;
/**
 * Deprecated version of findComponents. Renamed to searchComponents.
 * @param {import('@formio/core').Component[]} components - The components to find components within.
 * @param {object} query - The query to use when searching for the components.
 * @returns {import('@formio/core').Component[]} - The result of the component that is found.
 */
function findComponents(components, query) {
    console.warn('formio.js/utils findComponents is deprecated. Use searchComponents instead.');
    return searchComponents(components, query);
}
exports.findComponents = findComponents;
/**
 * Remove a component by path.
 *
 * @param components
 * @param path
 */
function removeComponent(components, path) {
    // @ts-expect-error - I'm not sure why we're using `pop` here if it's a string
    const index = path.pop();
    if (path.length !== 0) {
        components = (0, lodash_1.get)(components, path);
    }
    components.splice(index, 1);
}
exports.removeComponent = removeComponent;
/**
 * Returns if this component has a conditional statement.
 *
 * @param component - The component JSON schema.
 *
 * @returns {boolean} - TRUE - This component has a conditional, FALSE - No conditional provided.
 */
function hasCondition(component) {
    return Boolean(component.customConditional ||
        (component.conditional &&
            (component.conditional.when ||
                component.conditional.json ||
                (component.conditional.conjunction &&
                    ((0, lodash_1.isBoolean)(component.conditional.show) ||
                        component.conditional.show) &&
                    !(0, lodash_1.isEmpty)(component.conditional.conditions)))));
}
exports.hasCondition = hasCondition;
/**
 * Extension of standard #parseFloat(value) function, that also clears input string.
 *
 * @param {any} value
 *   The value to parse.
 *
 * @returns {Number}
 *   Parsed value.
 */
function parseFloatExt(value) {
    return parseFloat((0, lodash_1.isString)(value) ? value.replace(/[^\de.+-]/gi, '') : value);
}
exports.parseFloatExt = parseFloatExt;
/**
 * Formats provided value in way how Currency component uses it.
 *
 * @param {any} value
 *   The value to format.
 *
 * @returns {String}
 *   Value formatted for Currency component.
 */
function formatAsCurrency(value) {
    const parsedValue = parseFloatExt(value);
    if (isNaN(parsedValue)) {
        return '';
    }
    const parts = (0, lodash_1.round)(parsedValue, 2).toString().split('.');
    parts[0] = (0, lodash_1.chunk)(Array.from(parts[0]).reverse(), 3)
        .reverse()
        .map((part) => part.reverse().join(''))
        .join(',');
    parts[1] = (0, lodash_1.pad)(parts[1], 2, '0');
    return parts.join('.');
}
exports.formatAsCurrency = formatAsCurrency;
/**
 * Escapes RegEx characters in provided String value.
 *
 * @param {String} value
 *   String for escaping RegEx characters.
 * @returns {string}
 *   String with escaped RegEx characters.
 */
function escapeRegExCharacters(value) {
    return value.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
}
exports.escapeRegExCharacters = escapeRegExCharacters;
/**
 * Get the value for a component key, in the given submission.
 *
 * @param {Object} submission
 *   A submission object to search.
 * @param {String} key
 *   A for components API key to search for.
 */
function getValue(submission, key) {
    const search = (data) => {
        if ((0, lodash_1.isPlainObject)(data)) {
            if ((0, lodash_1.has)(data, key)) {
                return (0, lodash_1.get)(data, key);
            }
            let value = null;
            (0, lodash_1.forOwn)(data, (prop) => {
                const result = search(prop);
                if (!(0, lodash_1.isNil)(result)) {
                    value = result;
                    return false;
                }
            });
            return value;
        }
        else {
            return null;
        }
    };
    return search(submission.data);
}
exports.getValue = getValue;
/**
 * Iterate over all components in a form and get string values for translation.
 * @param form
 */
function getStrings(form) {
    const properties = [
        'label',
        'title',
        'legend',
        'tooltip',
        'description',
        'placeholder',
        'prefix',
        'suffix',
        'errorLabel',
        'content',
        'html',
    ];
    const strings = [];
    (0, eachComponent_1.eachComponent)(form.components, (component) => {
        properties.forEach((property) => {
            if (component.hasOwnProperty(property) && component[property]) {
                strings.push({
                    key: component.key,
                    type: component.type,
                    property,
                    string: component[property],
                });
            }
        });
        if ((!component.dataSrc || component.dataSrc === 'values') &&
            component.hasOwnProperty('values') &&
            Array.isArray(component.values) &&
            component.values.length) {
            component.values.forEach((value, index) => {
                strings.push({
                    key: component.key,
                    property: `value[${index}].label`,
                    string: component.values[index].label,
                });
            });
        }
        // Hard coded values from Day component
        if (component.type === 'day') {
            [
                'day',
                'month',
                'year',
                'Day',
                'Month',
                'Year',
                'january',
                'february',
                'march',
                'april',
                'may',
                'june',
                'july',
                'august',
                'september',
                'october',
                'november',
                'december',
            ].forEach((string) => {
                strings.push({
                    key: component.key,
                    property: 'day',
                    string,
                });
            });
            if (component.fields.day.placeholder) {
                strings.push({
                    key: component.key,
                    property: 'fields.day.placeholder',
                    string: component.fields.day.placeholder,
                });
            }
            if (component.fields.month.placeholder) {
                strings.push({
                    key: component.key,
                    property: 'fields.month.placeholder',
                    string: component.fields.month.placeholder,
                });
            }
            if (component.fields.year.placeholder) {
                strings.push({
                    key: component.key,
                    property: 'fields.year.placeholder',
                    string: component.fields.year.placeholder,
                });
            }
        }
        if (component.type === 'editgrid') {
            const string = component.addAnother || 'Add Another';
            if (component.addAnother) {
                strings.push({
                    key: component.key,
                    property: 'addAnother',
                    string,
                });
            }
        }
        if (component.type === 'select') {
            ['loading...', 'Type to search'].forEach((string) => {
                strings.push({
                    key: component.key,
                    property: 'select',
                    string,
                });
            });
        }
    }, true);
    return strings;
}
exports.getStrings = getStrings;
// ?????????????????????????
// questionable section
function generateFormChange(type, data) {
    let change;
    switch (type) {
        case 'add':
            change = {
                op: 'add',
                key: data.component.key,
                container: data.parent.key, // Parent component
                path: data.path, // Path to container within parent component.
                index: data.index, // Index of component in parent container.
                component: data.component,
            };
            break;
        case 'edit':
            change = {
                op: 'edit',
                key: data.originalComponent.key,
                patches: (0, fast_json_patch_1.compare)(data.originalComponent, data.component),
            };
            // Don't save if nothing changed.
            if (!change.patches.length) {
                change = null;
            }
            break;
        case 'remove':
            change = {
                op: 'remove',
                key: data.component.key,
            };
            break;
    }
    return change;
}
exports.generateFormChange = generateFormChange;
function applyFormChanges(form, changes) {
    const failed = [];
    changes.forEach(function (change) {
        let found = false;
        switch (change.op) {
            case 'add': {
                let newComponent = change.component;
                // Find the container to set the component in.
                findComponent(form.components, change.container, null, function (parent) {
                    if (!change.container) {
                        parent = form;
                    }
                    // A move will first run an add so remove any existing components with matching key before inserting.
                    findComponent(form.components, change.key, null, function (component, path) {
                        // If found, use the existing component. (If someone else edited it, the changes would be here)
                        newComponent = component;
                        removeComponent(form.components, path);
                    });
                    found = true;
                    const container = (0, lodash_1.get)(parent, change.path);
                    container.splice(change.index, 0, newComponent);
                });
                break;
            }
            case 'remove':
                findComponent(form.components, change.key, null, function (component, path) {
                    found = true;
                    const oldComponent = (0, lodash_1.get)(form.components, path);
                    if (oldComponent.key !== component.key) {
                        path.pop();
                    }
                    removeComponent(form.components, path);
                });
                break;
            case 'edit':
                findComponent(form.components, change.key, null, function (component, path) {
                    found = true;
                    try {
                        const oldComponent = (0, lodash_1.get)(form.components, path);
                        const newComponent = (0, fast_json_patch_1.applyPatch)(component, change.patches).newDocument;
                        if (oldComponent.key !== newComponent.key) {
                            path.pop();
                        }
                        (0, lodash_1.set)(form.components, path, newComponent);
                    }
                    catch (ignoreErr) {
                        failed.push(change);
                    }
                });
                break;
            case 'move':
                break;
        }
        if (!found) {
            failed.push(change);
        }
    });
    return {
        form,
        failed,
    };
}
exports.applyFormChanges = applyFormChanges;
/**
 * This function will find a component in a form and return the component AND THE PATH to the component in the form.
 * Path to the component is stored as an array of nested components and their indexes.The Path is being filled recursively
 * when you iterating through the nested structure.
 * If the component is not found the callback won't be called and function won't return anything.
 *
 * @param components
 * @param key
 * @param fn
 * @param path
 * @returns {*}
 */
function findComponent(components, key, path, fn) {
    if (!components)
        return;
    path = path || [];
    if (!key) {
        return fn(components);
    }
    components.forEach(function (component, index) {
        const newPath = path.slice();
        // Add an index of the component it iterates through in nested structure
        newPath.push(index);
        if (!component)
            return;
        if (component.hasOwnProperty('columns') && Array.isArray(component.columns)) {
            newPath.push('columns');
            component.columns.forEach(function (column, index) {
                const colPath = newPath.slice();
                colPath.push(index);
                colPath.push('components');
                findComponent(column.components, key, colPath, fn);
            });
        }
        if (component.hasOwnProperty('rows') && Array.isArray(component.rows)) {
            newPath.push('rows');
            component.rows.forEach(function (row, index) {
                const rowPath = newPath.slice();
                rowPath.push(index);
                row.forEach(function (column, index) {
                    const colPath = rowPath.slice();
                    colPath.push(index);
                    colPath.push('components');
                    findComponent(column.components, key, colPath, fn);
                });
            });
        }
        if (component.hasOwnProperty('components') && Array.isArray(component.components)) {
            newPath.push('components');
            findComponent(component.components, key, newPath, fn);
        }
        if (component.key === key) {
            //Final callback if the component is found
            fn(component, newPath, components);
        }
    });
}
exports.findComponent = findComponent;
const isCheckboxComponent = (component) => (component === null || component === void 0 ? void 0 : component.type) === 'checkbox';
const isDataGridComponent = (component) => (component === null || component === void 0 ? void 0 : component.type) === 'datagrid';
const isEditGridComponent = (component) => (component === null || component === void 0 ? void 0 : component.type) === 'editgrid';
const isAddressComponent = (component) => (component === null || component === void 0 ? void 0 : component.type) === 'address';
const isDataTableComponent = (component) => (component === null || component === void 0 ? void 0 : component.type) === 'datatable';
const hasChildComponents = (component) => (component === null || component === void 0 ? void 0 : component.components) != null;
const isDateTimeComponent = (component) => (component === null || component === void 0 ? void 0 : component.type) === 'datetime';
const isSelectBoxesComponent = (component) => (component === null || component === void 0 ? void 0 : component.type) === 'selectboxes';
const isTextAreaComponent = (component) => (component === null || component === void 0 ? void 0 : component.type) === 'textarea';
const isTextFieldComponent = (component) => (component === null || component === void 0 ? void 0 : component.type) === 'textfield';
function getEmptyValue(component) {
    switch (component.type) {
        case 'textarea':
        case 'textfield':
        case 'time':
        case 'datetime':
        case 'day':
            return '';
        case 'datagrid':
        case 'editgrid':
            return [];
        default:
            return null;
    }
}
exports.getEmptyValue = getEmptyValue;
const replaceBlanks = (value) => {
    const nbsp = '<p>&nbsp;</p>';
    const br = '<p><br></p>';
    const brNbsp = '<p><br>&nbsp;</p>';
    const regExp = new RegExp(`^${nbsp}|${nbsp}$|^${br}|${br}$|^${brNbsp}|${brNbsp}$`, 'g');
    return typeof value === 'string' ? value.replace(regExp, '').trim() : value;
};
function trimBlanks(value) {
    if (!value) {
        return value;
    }
    if (Array.isArray(value)) {
        value = value.map((val) => replaceBlanks(val));
    }
    else {
        value = replaceBlanks(value);
    }
    return value;
}
function isValueEmpty(component, value) {
    const compValueIsEmptyArray = (0, lodash_1.isArray)(value) && value.length === 1 ? (0, lodash_1.isEqual)(value[0], getEmptyValue(component)) : false;
    return (value == null || value === '' || ((0, lodash_1.isArray)(value) && value.length === 0) || compValueIsEmptyArray);
}
function isComponentDataEmpty(component, data, path, valueCond) {
    var _a;
    const value = (0, lodash_1.isNil)(valueCond) ? (0, lodash_1.get)(data, path) : valueCond;
    const addressIgnoreProperties = ['mode', 'address'];
    if (isCheckboxComponent(component)) {
        return isValueEmpty(component, value) || value === false;
    }
    else if (isAddressComponent(component)) {
        if (Object.keys(value).length === 0) {
            return true;
        }
        return !Object.values((0, lodash_1.omit)(value, addressIgnoreProperties)).some(Boolean);
    }
    else if (isDataGridComponent(component) ||
        isEditGridComponent(component) ||
        isDataTableComponent(component) ||
        hasChildComponents(component)) {
        if ((_a = component.components) === null || _a === void 0 ? void 0 : _a.length) {
            let childrenEmpty = true;
            // wrap component in an array to let eachComponentData handle introspection to child components (e.g. this will be different
            // for data grids versus nested forms, etc.)
            (0, eachComponentData_1.eachComponentData)([component], data, (thisComponent, data, row, path) => {
                if (component.key === thisComponent.key)
                    return;
                if (!isComponentDataEmpty(thisComponent, data, path)) {
                    childrenEmpty = false;
                }
            });
            return isValueEmpty(component, value) || childrenEmpty;
        }
        return isValueEmpty(component, value);
    }
    else if (isDateTimeComponent(component)) {
        return isValueEmpty(component, value) || value.toString() === 'Invalid date';
    }
    else if (isSelectBoxesComponent(component)) {
        let selectBoxEmpty = true;
        for (const key in value) {
            if (value[key]) {
                selectBoxEmpty = false;
                break;
            }
        }
        return isValueEmpty(component, value) || selectBoxEmpty;
    }
    else if (isTextAreaComponent(component)) {
        const isPlain = !component.wysiwyg && !component.editor;
        return isPlain
            ? typeof value === 'string'
                ? isValueEmpty(component, value.trim())
                : isValueEmpty(component, value)
            : isValueEmpty(component, trimBlanks(value));
    }
    else if (isTextFieldComponent(component)) {
        if (component.allowMultipleMasks && !!component.inputMasks && !!component.inputMasks.length) {
            return (isValueEmpty(component, value) ||
                (component.multiple ? value.length === 0 : !value.maskName || !value.value));
        }
        return isValueEmpty(component, value === null || value === void 0 ? void 0 : value.toString().trim());
    }
    return isValueEmpty(component, value);
}
exports.isComponentDataEmpty = isComponentDataEmpty;
/**
 * Returns the template keys inside the template code.
 * @param {string} template - The template to get the keys from.
 * @returns {Array<string>} - The keys inside the template.
 */
function getItemTemplateKeys(template) {
    const templateKeys = [];
    if (!template) {
        return templateKeys;
    }
    const keys = template.match(/({{\s*(.*?)\s*}})/g);
    if (keys) {
        keys.forEach((key) => {
            const propKey = key.match(/{{\s*item\.(.*?)\s*}}/);
            if (propKey && propKey.length > 1) {
                templateKeys.push(propKey[1]);
            }
        });
    }
    return templateKeys;
}
exports.getItemTemplateKeys = getItemTemplateKeys;
/**
 * Returns if the component is a select resource with an object for its value.
 * @param {Component} comp - The component to check.
 * @returns {boolean} - TRUE if the component is a select resource with an object for its value; FALSE otherwise.
 */
function isSelectResourceWithObjectValue(comp = {}) {
    const { reference, dataSrc, valueProperty } = comp;
    return reference || (dataSrc === 'resource' && (!valueProperty || valueProperty === 'data'));
}
exports.isSelectResourceWithObjectValue = isSelectResourceWithObjectValue;
/**
 * Compares real select resource value with expected value in condition.
 * @param {any} value - current value of selectcomponent.
 * @param {any} comparedValue - expocted value of select component.
 * @param {SelectComponent} conditionComponent - select component on which the condtion is based.
 * @returns {boolean} - TRUE if the select component current value is equal to the expected value; FALSE otherwise.
 */
function compareSelectResourceWithObjectTypeValues(value, comparedValue, conditionComponent) {
    if (!value || !(0, lodash_1.isPlainObject)(value)) {
        return false;
    }
    const { template, valueProperty } = conditionComponent;
    if (valueProperty === 'data') {
        value = { data: value };
        comparedValue = { data: comparedValue };
    }
    return (0, lodash_1.every)(getItemTemplateKeys(template) || [], (k) => (0, lodash_1.isEqual)((0, lodash_1.get)(value, k), (0, lodash_1.get)(comparedValue, k)));
}
exports.compareSelectResourceWithObjectTypeValues = compareSelectResourceWithObjectTypeValues;
function getComponentErrorField(component, context) {
    const toInterpolate = component.errorLabel || component.label || component.placeholder || component.key;
    return Evaluator_1.Evaluator.interpolate(toInterpolate, context);
}
exports.getComponentErrorField = getComponentErrorField;
/**
 * Normalize a context object so that it contains the correct paths and data, and so it can pass into and out of a sandbox for evaluation
 * @param context
 * @returns
 */
function normalizeContext(context) {
    const { data, paths, local, path, form, submission, row, component, instance, value, options, scope, config, } = context;
    return {
        path: paths ? paths.localDataPath : path,
        data: paths ? getComponentLocalData(paths, data, local) : data,
        paths,
        form,
        scope,
        submission,
        row,
        component,
        instance,
        value,
        input: value,
        config,
        options,
    };
}
exports.normalizeContext = normalizeContext;
