"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eachComponentData = void 0;
const lodash_1 = require("lodash");
const index_1 = require("./index");
const eachComponent_1 = require("./eachComponent");
/**
 * Iterates through each component as well as its data, and triggers a callback for every component along
 * with the contextual data for that component in addition to the absolute path for that component.
 * @param components - The array of JSON components to iterate through.
 * @param data - The contextual data object for the components.
 * @param fn - The callback function to trigger for each component following the signature (component, data, row, path, components, index, parent).
 * @param parent - The parent component.
 * @param includeAll
 * @returns
 */
const eachComponentData = (components, data, fn, includeAll = false, local = false, parent, parentPaths, noScopeReset, afterFn) => {
    if (!components) {
        return;
    }
    return (0, eachComponent_1.eachComponent)(components, (component, compPath, componentComponents, compParent, compPaths) => {
        const row = (0, index_1.getContextualRowData)(component, data, compPaths, local);
        const callAfterFn = () => {
            if (afterFn) {
                return afterFn(component, data, row, (component.modelType === 'none' ? compPaths === null || compPaths === void 0 ? void 0 : compPaths.fullPath : compPaths === null || compPaths === void 0 ? void 0 : compPaths.dataPath) || '', componentComponents, compPaths === null || compPaths === void 0 ? void 0 : compPaths.dataIndex, compParent, compPaths);
            }
        };
        if (fn(component, data, row, (component.modelType === 'none' ? compPaths === null || compPaths === void 0 ? void 0 : compPaths.fullPath : compPaths === null || compPaths === void 0 ? void 0 : compPaths.dataPath) || '', componentComponents, compPaths === null || compPaths === void 0 ? void 0 : compPaths.dataIndex, compParent, compPaths) === true) {
            callAfterFn();
            if (!noScopeReset) {
                (0, index_1.resetComponentScope)(component);
            }
            return true;
        }
        if ((0, index_1.isComponentNestedDataType)(component)) {
            const value = (0, lodash_1.get)(data, local ? (compPaths === null || compPaths === void 0 ? void 0 : compPaths.localDataPath) || '' : (compPaths === null || compPaths === void 0 ? void 0 : compPaths.dataPath) || '');
            if ((0, index_1.getModelType)(component) === 'nestedArray' ||
                (0, index_1.getModelType)(component) === 'nestedDataArray') {
                if (Array.isArray(value) && value.length) {
                    for (let i = 0; i < value.length; i++) {
                        if (!value[i]) {
                            continue;
                        }
                        if (compPaths) {
                            compPaths.dataIndex = i;
                        }
                        (0, exports.eachComponentData)(component.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn);
                    }
                    if (compPaths) {
                        compPaths.dataIndex = undefined;
                    }
                }
                else if (includeAll || (0, lodash_1.isUndefined)(value)) {
                    (0, exports.eachComponentData)(component.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn);
                }
                callAfterFn();
                if (!noScopeReset) {
                    (0, index_1.resetComponentScope)(component);
                }
                return true;
            }
            else {
                const shouldProcess = (0, index_1.shouldProcessComponent)(component, value, compPaths);
                if (!includeAll && !shouldProcess) {
                    callAfterFn();
                    if (!noScopeReset) {
                        (0, index_1.resetComponentScope)(component);
                    }
                    return true;
                }
                (0, exports.eachComponentData)(component.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn);
            }
            callAfterFn();
            if (!noScopeReset) {
                (0, index_1.resetComponentScope)(component);
            }
            return true;
        }
        else if (!component.type || (0, index_1.getModelType)(component) === 'none') {
            const info = (0, index_1.componentInfo)(component);
            if (info.hasColumns) {
                component.columns.forEach((column) => (0, exports.eachComponentData)(column.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn));
            }
            else if (info.hasRows) {
                component.rows.forEach((row) => {
                    if (Array.isArray(row)) {
                        row.forEach((row) => (0, exports.eachComponentData)(row.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn));
                    }
                });
            }
            else if (info.hasComps) {
                (0, exports.eachComponentData)(component.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn);
            }
            callAfterFn();
            if (!noScopeReset) {
                (0, index_1.resetComponentScope)(component);
            }
            return true;
        }
        callAfterFn();
        if (!noScopeReset) {
            (0, index_1.resetComponentScope)(component);
        }
        return false;
    }, true, parentPaths, parent);
};
exports.eachComponentData = eachComponentData;
