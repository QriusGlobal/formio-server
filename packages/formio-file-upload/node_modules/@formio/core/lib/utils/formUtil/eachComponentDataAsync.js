"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.eachComponentDataAsync = void 0;
const lodash_1 = require("lodash");
const index_1 = require("./index");
const eachComponentAsync_1 = require("./eachComponentAsync");
// Async each component data.
const eachComponentDataAsync = (components_1, data_1, fn_1, ...args_1) => __awaiter(void 0, [components_1, data_1, fn_1, ...args_1], void 0, function* (components, data, fn, includeAll = false, local = false, parent, parentPaths, noScopeReset, afterFn) {
    if (!components) {
        return;
    }
    return yield (0, eachComponentAsync_1.eachComponentAsync)(components, (component, compPath, componentComponents, compParent, compPaths) => __awaiter(void 0, void 0, void 0, function* () {
        const row = (0, index_1.getContextualRowData)(component, data, compPaths, local);
        const callAfterFn = () => __awaiter(void 0, void 0, void 0, function* () {
            if (afterFn) {
                yield afterFn(component, data, row, (component.modelType === 'none' ? compPaths === null || compPaths === void 0 ? void 0 : compPaths.fullPath : compPaths === null || compPaths === void 0 ? void 0 : compPaths.dataPath) || '', componentComponents, compPaths === null || compPaths === void 0 ? void 0 : compPaths.dataIndex, compParent, compPaths);
            }
        });
        if ((yield fn(component, data, row, (component.modelType === 'none' ? compPaths === null || compPaths === void 0 ? void 0 : compPaths.fullPath : compPaths === null || compPaths === void 0 ? void 0 : compPaths.dataPath) || '', componentComponents, compPaths === null || compPaths === void 0 ? void 0 : compPaths.dataIndex, compParent, compPaths)) === true) {
            yield callAfterFn();
            if (!noScopeReset) {
                (0, index_1.resetComponentScope)(component);
            }
            return true;
        }
        if ((0, index_1.isComponentNestedDataType)(component)) {
            const value = (0, lodash_1.get)(data, local ? (compPaths === null || compPaths === void 0 ? void 0 : compPaths.localDataPath) || '' : (compPaths === null || compPaths === void 0 ? void 0 : compPaths.dataPath) || '');
            if ((0, index_1.getModelType)(component) === 'nestedArray' ||
                (0, index_1.getModelType)(component) === 'nestedDataArray') {
                if (Array.isArray(value) && value.length) {
                    for (let i = 0; i < value.length; i++) {
                        if (!value[i]) {
                            continue;
                        }
                        if (compPaths) {
                            compPaths.dataIndex = i;
                        }
                        yield (0, exports.eachComponentDataAsync)(component.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn);
                    }
                    if (compPaths) {
                        compPaths.dataIndex = undefined;
                    }
                }
                else if (includeAll) {
                    yield (0, exports.eachComponentDataAsync)(component.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn);
                }
                yield callAfterFn();
                if (!noScopeReset) {
                    (0, index_1.resetComponentScope)(component);
                }
                return true;
            }
            else {
                const shouldProcess = (0, index_1.shouldProcessComponent)(component, value, compPaths);
                if (!includeAll && !shouldProcess) {
                    yield callAfterFn();
                    if (!noScopeReset) {
                        (0, index_1.resetComponentScope)(component);
                    }
                    return true;
                }
                yield (0, exports.eachComponentDataAsync)(component.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn);
            }
            yield callAfterFn();
            if (!noScopeReset) {
                (0, index_1.resetComponentScope)(component);
            }
            return true;
        }
        else if (!component.type || (0, index_1.getModelType)(component) === 'none') {
            const info = (0, index_1.componentInfo)(component);
            if (info.hasColumns) {
                const columnsComponent = component;
                for (const column of columnsComponent.columns) {
                    yield (0, exports.eachComponentDataAsync)(column.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn);
                }
            }
            else if (info.hasRows) {
                const rowsComponent = component;
                for (const rowArray of rowsComponent.rows) {
                    if (Array.isArray(rowArray)) {
                        for (const row of rowArray) {
                            yield (0, exports.eachComponentDataAsync)(row.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn);
                        }
                    }
                }
            }
            else if (info.hasComps) {
                yield (0, exports.eachComponentDataAsync)(component.components, data, fn, includeAll, local, component, compPaths, noScopeReset, afterFn);
            }
            yield callAfterFn();
            if (!noScopeReset) {
                (0, index_1.resetComponentScope)(component);
            }
            return true;
        }
        yield callAfterFn();
        if (!noScopeReset) {
            (0, index_1.resetComponentScope)(component);
        }
        return false;
    }), true, parentPaths, parent);
});
exports.eachComponentDataAsync = eachComponentDataAsync;
