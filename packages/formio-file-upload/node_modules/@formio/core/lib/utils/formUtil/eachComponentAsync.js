"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.eachComponentAsync = void 0;
const index_1 = require("./index");
// Async each component.
function eachComponentAsync(components_1, fn_1) {
    return __awaiter(this, arguments, void 0, function* (components, fn, includeAll = false, parentPaths, parent) {
        var _a, _b;
        if (!components)
            return;
        if (typeof parentPaths === 'string') {
            parentPaths = { path: parentPaths };
        }
        for (let i = 0; i < components.length; i++) {
            if (!components[i]) {
                continue;
            }
            const component = components[i];
            const info = (0, index_1.componentInfo)(component);
            const compPaths = (0, index_1.getComponentPaths)(component, parent, parentPaths);
            if (includeAll || component.tree || !info.layout) {
                const path = includeAll ? compPaths.fullPath : compPaths.path;
                if (yield fn(component, path || '', components, parent, compPaths)) {
                    continue;
                }
            }
            if (info.hasColumns) {
                for (let j = 0; j < component.columns.length; j++) {
                    yield eachComponentAsync((_a = component.columns[j]) === null || _a === void 0 ? void 0 : _a.components, fn, includeAll, compPaths, component);
                }
            }
            else if (info.hasRows) {
                for (let j = 0; j < component.rows.length; j++) {
                    const row = component.rows[j];
                    if (Array.isArray(row)) {
                        for (let k = 0; k < row.length; k++) {
                            yield eachComponentAsync((_b = row[k]) === null || _b === void 0 ? void 0 : _b.components, fn, includeAll, compPaths, component);
                        }
                    }
                }
            }
            else if (info.hasComps) {
                yield eachComponentAsync(component.components, fn, includeAll, compPaths, component);
            }
        }
    });
}
exports.eachComponentAsync = eachComponentAsync;
