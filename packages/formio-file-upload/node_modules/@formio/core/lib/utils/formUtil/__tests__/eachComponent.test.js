"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const fixtures_1 = require("../fixtures");
const eachComponent_1 = require("../eachComponent");
const index_1 = require("../index");
describe('eachComponent', function () {
    it('should iterate through nested components in the right order', function () {
        let n = 1;
        (0, eachComponent_1.eachComponent)(fixtures_1.textFieldsNestedInLayoutComponents, (component) => {
            (0, chai_1.expect)(component.order).to.equal(n);
            n += 1;
        });
    });
    it('should include layouts components if provided', function () {
        let numComps = 0;
        let numLayout = 0;
        (0, eachComponent_1.eachComponent)(fixtures_1.textFieldsNestedInLayoutComponents, (component) => {
            if ((0, index_1.isLayoutComponent)(component)) {
                numLayout++;
            }
            else {
                numComps++;
            }
        }, true);
        (0, chai_1.expect)(numLayout).to.be.equal(3);
        (0, chai_1.expect)(numComps).to.be.equal(8);
    });
    it('Should provide the paths to all of the components if includeAll=true', function () {
        const paths = [
            'one',
            'parent1',
            'parent1.two',
            'parent1.parent2',
            'parent1.parent2.three',
            'parent1.parent2',
            'parent1.parent2.four',
            'parent1.parent2.five',
            'parent1.parent2.six',
            'parent1.parent2.seven',
            'eight',
        ];
        const testPaths = [];
        (0, eachComponent_1.eachComponent)(fixtures_1.textFieldsNestedInLayoutComponents, (component, path) => {
            testPaths.push(path);
        }, true);
        (0, chai_1.expect)(paths).to.deep.equal(testPaths);
    });
    it('Should iterate over each component given a flat components array', function () {
        const components = [
            {
                type: 'textfield',
                key: 'textField',
                input: true,
            },
            {
                type: 'textarea',
                key: 'textArea',
                input: true,
            },
        ];
        const rowResults = new Map();
        (0, eachComponent_1.eachComponent)(components, (component, path) => {
            rowResults.set(path, component);
        });
        (0, chai_1.expect)(rowResults.size).to.equal(2);
        (0, chai_1.expect)(rowResults.get('textField')).to.deep.equal({
            type: 'textfield',
            key: 'textField',
            input: true,
        });
        (0, chai_1.expect)(rowResults.get('textArea')).to.deep.equal({
            type: 'textarea',
            key: 'textArea',
            input: true,
        });
    });
    it('Should iterate over each component with correct pathing given a container component', function () {
        const components = [
            {
                type: 'textfield',
                key: 'textField',
                input: true,
            },
            {
                type: 'container',
                key: 'container',
                input: true,
                components: [
                    {
                        type: 'textfield',
                        key: 'nestedTextField',
                        input: true,
                    },
                    {
                        type: 'textarea',
                        key: 'nestedTextArea',
                        input: true,
                    },
                ],
            },
        ];
        const rowResults = new Map();
        (0, eachComponent_1.eachComponent)(components, (component, path) => {
            rowResults.set(path, component);
        }, true);
        (0, chai_1.expect)(rowResults.size).to.equal(4);
        (0, chai_1.expect)(rowResults.get('textField')).to.deep.equal({
            type: 'textfield',
            key: 'textField',
            input: true,
        });
        (0, chai_1.expect)(rowResults.get('container')).to.deep.equal({
            type: 'container',
            key: 'container',
            input: true,
            components: [
                {
                    type: 'textfield',
                    key: 'nestedTextField',
                    input: true,
                },
                {
                    type: 'textarea',
                    key: 'nestedTextArea',
                    input: true,
                },
            ],
        });
        (0, chai_1.expect)(rowResults.get('container.nestedTextField')).to.deep.equal({
            type: 'textfield',
            key: 'nestedTextField',
            input: true,
        });
        (0, chai_1.expect)(rowResults.get('container.nestedTextArea')).to.deep.equal({
            type: 'textarea',
            key: 'nestedTextArea',
            input: true,
        });
    });
    it('Should iterate over each component with correct pathing given a datagrid component', function () {
        const components = [
            {
                type: 'textfield',
                key: 'textField',
                input: true,
            },
            {
                type: 'datagrid',
                key: 'dataGrid',
                input: true,
                components: [
                    {
                        type: 'textfield',
                        key: 'nestedTextField',
                        input: true,
                    },
                    {
                        type: 'textarea',
                        key: 'nestedTextArea',
                        input: true,
                    },
                ],
            },
        ];
        const rowResults = new Map();
        (0, eachComponent_1.eachComponent)(components, (component, path) => {
            rowResults.set(path, component);
        }, true);
        (0, chai_1.expect)(rowResults.size).to.equal(4);
        (0, chai_1.expect)(rowResults.get('textField')).to.deep.equal({
            type: 'textfield',
            key: 'textField',
            input: true,
        });
        (0, chai_1.expect)(rowResults.get('dataGrid')).to.deep.equal({
            type: 'datagrid',
            key: 'dataGrid',
            input: true,
            components: [
                {
                    type: 'textfield',
                    key: 'nestedTextField',
                    input: true,
                },
                {
                    type: 'textarea',
                    key: 'nestedTextArea',
                    input: true,
                },
            ],
        });
        (0, chai_1.expect)(rowResults.get('dataGrid.nestedTextField')).to.deep.equal({
            type: 'textfield',
            key: 'nestedTextField',
            input: true,
        });
        (0, chai_1.expect)(rowResults.get('dataGrid.nestedTextArea')).to.deep.equal({
            type: 'textarea',
            key: 'nestedTextArea',
            input: true,
        });
    });
    it("Should iterate over each component with correct pathing given a datagrid's child components", function () {
        const components = [
            {
                type: 'datagrid',
                key: 'dataGrid',
                input: true,
                components: [
                    {
                        type: 'textfield',
                        key: 'nestedTextField',
                        input: true,
                    },
                    {
                        type: 'textarea',
                        key: 'nestedTextArea',
                        input: true,
                    },
                ],
            },
        ];
        const rowResults = new Map();
        (0, eachComponent_1.eachComponent)(components, (component, path) => {
            rowResults.set(path, component);
        }, true);
        (0, chai_1.expect)(rowResults.size).to.equal(3);
        (0, chai_1.expect)(rowResults.get('dataGrid.nestedTextField')).to.deep.equal({
            type: 'textfield',
            key: 'nestedTextField',
            input: true,
        });
        (0, chai_1.expect)(rowResults.get('dataGrid.nestedTextArea')).to.deep.equal({
            type: 'textarea',
            key: 'nestedTextArea',
            input: true,
        });
    });
    it('Should be able to generate paths based on component types', function () {
        const paths = [
            'a',
            'b',
            'b.c',
            'b.c.d',
            'b.c.f',
            'b.c.f.g',
            'b.c.f.h',
            'b.c.f.i',
            'b.c.e',
            'b.j',
            'k',
            'k.n',
            'k.n.o',
            'k.n.p',
            'k.n.q',
            'k.m',
            'k.l',
            'r',
            'submit',
            'tagpad',
            'tagpad.a',
        ];
        const testPaths = [];
        (0, eachComponent_1.eachComponent)(fixtures_1.nestedArrayDataComponents, (component, path) => {
            testPaths.push(path);
        }, true);
        (0, chai_1.expect)(paths).to.deep.equal(testPaths);
    });
    it('Should still provide the correct paths when it is not recursive', function () {
        const paths = [
            'a',
            'd',
            'f',
            'f.g',
            'f.h',
            'f.i',
            'e',
            'j',
            'k',
            'k.n',
            'k.n.o',
            'k.n.p',
            'k.n.q',
            'k.m',
            'k.l',
            'r',
            'submit',
            'tagpad',
            'tagpad.a',
        ];
        const testPaths = [];
        (0, eachComponent_1.eachComponent)(fixtures_1.nestedArrayDataComponents, (component, path) => {
            testPaths.push(path);
        });
        (0, chai_1.expect)(paths).to.deep.equal(testPaths);
    });
    it('should be able to block recursion', function () {
        let numComps = 0;
        let numLayout = 0;
        (0, eachComponent_1.eachComponent)(fixtures_1.textFieldsNestedInLayoutComponents, (component) => {
            if ((0, index_1.isLayoutComponent)(component)) {
                numLayout++;
            }
            else {
                numComps++;
            }
            if (component.type === 'table') {
                let numInTable = 0;
                const tableComponent = component;
                tableComponent.rows.forEach((row) => {
                    row.forEach((comp) => {
                        (0, eachComponent_1.eachComponent)(comp.components, () => {
                            numInTable++;
                        });
                    });
                });
                (0, chai_1.expect)(numInTable).to.be.equal(4);
                return true;
            }
        }, true);
        (0, chai_1.expect)(numLayout).to.be.equal(3);
        (0, chai_1.expect)(numComps).to.be.equal(4);
    });
    it('should not include `htmlelement` components when `includeAll` is not provided', function () {
        let htmlComponentsAmount = 0;
        (0, eachComponent_1.eachComponent)(fixtures_1.mixedLayoutAndDataComponents, (component) => {
            if (component.type === 'htmlelement') {
                htmlComponentsAmount++;
            }
        });
        (0, chai_1.expect)(htmlComponentsAmount).to.be.equal(0);
    });
    it('should include `htmlelement` components when `includeAll` is provided', function () {
        let htmlComponentsAmount = 0;
        (0, eachComponent_1.eachComponent)(fixtures_1.mixedLayoutAndDataComponents, (component) => {
            if (component.type === 'htmlelement') {
                htmlComponentsAmount++;
            }
        }, true);
        (0, chai_1.expect)(htmlComponentsAmount).to.be.equal(1);
    });
    it('should not include `content` components when `includeAll` is not provided', function () {
        let contentComponentsAmount = 0;
        (0, eachComponent_1.eachComponent)(fixtures_1.mixedLayoutAndDataComponents, (component) => {
            if (component.type === 'content') {
                contentComponentsAmount++;
            }
        });
        (0, chai_1.expect)(contentComponentsAmount).to.be.equal(0);
    });
    it('should include `content` components when `includeAll` is provided', function () {
        let contentComponentsAmount = 0;
        (0, eachComponent_1.eachComponent)(fixtures_1.mixedLayoutAndDataComponents, (component) => {
            if (component.type === 'content') {
                contentComponentsAmount++;
            }
        }, true);
        (0, chai_1.expect)(contentComponentsAmount).to.be.equal(1);
    });
    it('Should get the absolute paths correctly when iterating.', function () {
        const form = {
            key: 'form',
            display: 'form',
            components: [
                {
                    type: 'container',
                    key: 'outer-container',
                    components: [
                        {
                            type: 'textfield',
                            key: 'textfield',
                        },
                        {
                            type: 'container',
                            key: 'inner-container',
                            components: [
                                {
                                    type: 'textfield',
                                    key: 'innerTextfield',
                                },
                            ],
                        },
                    ],
                },
            ],
        };
        // when passed child components, absolute path returns relative to the parent component/
        (0, eachComponent_1.eachComponent)(form.components, (component, path, components, parent, paths) => {
            if (component.key === 'innerTextfield') {
                (0, chai_1.expect)(paths === null || paths === void 0 ? void 0 : paths.dataPath).to.equal('outer-container.inner-container.innerTextfield', 'absolute path path is incomplete');
            }
        });
    });
});
